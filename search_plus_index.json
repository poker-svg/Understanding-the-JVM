{"./":{"url":"./","title":"Introduction","keywords":"","body":"1. Introduction1. Introduction 这是我的《深入理解Java虚拟机》的读书笔记的gitbook，会时不时更新。 By YangXin Xu            updated 2023-09-28 18:37:33 "},"第1章-走进Java.html":{"url":"第1章-走进Java.html","title":"第1章-走进Java","keywords":"","body":"1. Java技术体系2. Java虚拟机家族2.1. 虚拟机始祖：Sun Classic/Exact VM2.2. 武林盟主2.3. 小家碧玉：Mobile/Embedded VM2.4. 天下第二：BEA JRockit/IBM J9 VM2.5. 软硬合璧：BEA Liquid VM/Azul VM2.6. 挑战者：Apache Harmony/Google Android Dalvik VM3. 实战：自己编译JDK3.1. 获取源码3.2. 系统需求3.3. 构建编译环境1. Java技术体系 Java技术体系可以分为以下四条主要的产品线： Java Card：支持Java小程序(Applets)运行在小内存设备(如智能卡)上的平台 Java ME(Micro Edition)：针对Java程序运行在移动终端上的平台，对Java API有所精简，并加入了移动终端的针对性支持 Java SE(Standard Edition)：支持面向桌面级应用的Java平台，提供了完整的Java核心API Java EE(Enterprise Edition)：支持使用多层架构的企业应用的Java平台，除了提供 Java SE API 外，还对其做了大量有针对性的扩充，并提供了相关的部署支持 2. Java虚拟机家族 2.1. 虚拟机始祖：Sun Classic/Exact VM Classic VM 只能使用纯解释器方式来执行Java代码，如果要使用即时编译器就必须进行外挂 Sun 提供的外挂编译器名为 sunwjit 。但是解释器和编译器不能配合、同时工作 JDK 1.2 时，曾在 Solaris 平台上发布过一款名为 Exact VM 虚拟机，它的编译执行系统已经具备现代高性能虚拟机的雏形，如：热点探测、两级即时编译器、编译器与解释器混合工作模式 等 Exact VM 因他使用 准确式内存管理(Exact Memory Management) 而得名：即虚拟机可以知道内存中某个位置的数据具体是什么类型 由于使用了准确式内存管理，Exact VM 可以抛弃以前 Classic VM 基于句柄的对象查找方式 2.2. 武林盟主 HotSpot 既继承了 Sun 之前两款商用虚拟机的优点，也有许多自己新的技术优势，如它名称中的 HotSpot (热点代码探测技术) 如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发 标准即时编译 和 栈上替换编译 行为 2.3. 小家碧玉：Mobile/Embedded VM Oracle 公司在Java ME这条产品线上的虚拟机名为 CDC-HI(Connected Device Configuration-Hotspot Implementation) 和 CLDC-HI(Connected Limited Device Configuration-Hotspot Implementation) CDC/CLDC 式一组在 JSR-139 和 JSR-218 规范中进行定义的Java API子集，这组规范希望在移动设备上建立统一的Java编程接口，上述两个虚拟机就是此组规范的参考实现 Java SE Embedded 里是 HotSpot 虚拟机，但为了适应嵌入式环境专门定制了裁剪的版本，尽可能在支持完整的 Java SE 功能的前提下向着减少内存消耗的方向优化 2.4. 天下第二：BEA JRockit/IBM J9 VM BEA System 公司的 JRockit 专注于服务端应用，因此其内部不包含解释器实现，全部代码依靠即时编译器编译后执行 JRockit 随着 BEA 被 Oracle 收购，现已不再继续发展，永远停留在 R28 版本 IBM J9 虚拟机的职责分离与模块化做得比 HotSpot 更优秀 2.5. 软硬合璧：BEA Liquid VM/Azul VM Liquid VM 也被称为 JRockit VE(Virtual Edition) ，它是BEA公司开发的可以直接运行在自家 Hypervisor 系统上的 JRockit 虚拟机的虚拟化版本 Liquid VM 本身不需要操作系统的支持，他自己实现了一个专用操作系统的必要功能，从而最大限度地发挥了硬件的能力，提升了Java程序的执行性能 Azul VM 是 Azul Systems 公司在 HotSpot 基础上进行大量改进，运行于自家 Vega 系统上的Java虚拟机 2.6. 挑战者：Apache Harmony/Google Android Dalvik VM Apache Harmony 是一个 Apache 软件基金会旗下以 Apache License 协议开源的实际兼容于JDK 5和JDK 6的Java程序运行平台，它含有自己的虚拟机和Java类库API Dalvik 虚拟机并不是一个Java虚拟机，它没有遵循《Java虚拟机规范》，不能直接执行Class文件。它使用的是寄存器架构而非常见的栈架构 Dalvik虚拟机曾是Android平台的核心组成部分之一，和Java有千丝万缕的联系： 它执行的DEX文件可以通过Class文件转换得来 它使用Java语法编写应用程序，可以直接使用绝大多数Java API 但是等到 Android 4.4 ，支持提前编译的ART虚拟机迅速崛起，并在 Android 5.0 里全面替代了 Dalvik 虚拟机 3. 实战：自己编译JDK 3.1. 获取源码 目前，OpenJDK 和 OracleJDK 代码实质上以达到完全一致的程度，所以我们编译的 OpenJDK 基本上可以认为性能、功能和执行逻辑上都和官方的 OracleJDK 是一致的 此次编译实践我们选择的版本是：OpenJDK 12 获取源码有以下两种方式： 直接从 repository 中 clone 源码到本地 从JDK的仓库中下载源码的压缩包 3.2. 系统需求 推荐在 Linux 或 MacOS 上构建 OpenJDK ，这两个系统在准备构建工具链和依赖项上要比在 Windows 或 Solaris 平台上要容易 原书作者使用的是 Ubuntu 18.04 LTS ，我用的是 CentOS 7 3.3. 构建编译环境 Linux 系统中需要使用 GCC 或 CLang 来编译，最低版本为 GCC 4.8 或 CLang 3.2，官方推荐版本为 GCC 7.8 或 CLang 9.1 OpenJDK 全部的依赖库如下所示 By YangXin Xu            updated 2023-09-28 20:06:40 "},"第2章-Java内存区域与内存溢出异常.html":{"url":"第2章-Java内存区域与内存溢出异常.html","title":"第2章-Java内存区域与内存溢出异常","keywords":"","body":"1. 运行时数据区域1.1. 程序计数器1.2. 本地方法栈1.3. Java堆1.4. 方法区1.5. 运行时常量池1.6. 直接内存2. HotSpot 虚拟机对象探秘2.1. 对象的创建2.2. 对象的内存布局2.2.1. 对象头2.2.2. 实例数据2.2.3. 对齐填充2.3. 对象的访问定位3. 实战：OutOfMemoryError异常1. 运行时数据区域 根据《Java虚拟机规范》，Java虚拟机所管理的内存将会包含如下几个运行时数据区域： 1.1. 程序计数器 程序计数器可以看作是当前线程所执行字节码的行号指示器，也是程序控制流的指示器 每条线程都会有一个独立的程序计数器，各条线程之间互不影响，独立存储 如果线程正在执行一个Java方法，PC记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地方法，PC值为空(Undefined) 1.2. 本地方法栈 本地方法栈和虚拟机栈所发挥的作用是非常相似的 虚拟机栈为虚拟机执行字节码服务 本地方法栈为虚拟机使用到的本地方法服务 1.3. Java堆 Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建 此内存区域仅存放 对象实例 。在《Java虚拟机规范》中对Java堆的描述是：”所有对象实例以及数组都应当在堆上分配“（如今这一点并不绝对） Java堆是 垃圾收集器 管理的内存区域，因此也被称为 GC堆 从分配内存的角度来看，所有线程共享的Java堆中可以划分出多个 线程私有的分配缓冲区 (Thread Local Allocation Buffer, TLAB) 。但任何划分Java堆的目的只是为了更好地回收内存、更快地分配内存。 Java堆的地址空间逻辑上连续，物理上可以处于不连续的内存空间中 Java堆既可以是固定大小的，也可以是可扩展的（主流） 1.4. 方法区 方法区也是各个线程共享的内存区域，用于存储已被虚拟机加载的 类型信息、常量、静态变量、即时编译器编译后的代码缓存 等数据 《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分。但方法区有个别名——“非堆” ，目的是与 Java堆 进行区分 方法区 和 永久代 并不等价： 由于 HotSpot 的流行，很多人将两者混为一谈，而这仅仅是因为当时的 HotSpot 虚拟机使用永久代来实现方法区 现在回过头来看，当年使用永久代来实现方法区的决定并不是一个好主意，因为这种设计导致了Java应用更容易遇到内存溢出的问题。甚至有极少数方法会因永久代的原因导致其在不同的虚拟机上有不同的表现 考虑到 HotSpot 未来的发展，在JDK 6的时候 HotSpot 开发团队就有放弃永久代，逐步改为采用本地内存来实现方法去的计划了，并最终于JDK 8完全废弃了永久代的概念 《Java虚拟机规范》对方法区的约束是非常宽松的。除了不需要连续的内存和可以选择固定大小或者可扩展外，甚至可以选择不实现垃圾收集 1.5. 运行时常量池 Class文件中包含 常量池表 ，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到 方法区的运行时常量池 中 运行时常量池 相对于 Class文件常量池 的另一个重要特征就是具备 动态性 。 Java语言并不要求常量一定只有在编译期才能产生，即Java程序运行期间也可以将新的常量放入池中 1.6. 直接内存 直接内存既不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域 JDK 1.4中新加入了 NIO 类，引入了一种基于 通道 与 缓冲区 的I/O方式，它可以使用 Native 函数库直接分配 堆外内存 ，然后通过一个存储在Java堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作 这种 直接内存 的机制能在一些场景中显著提高性能，因为它避免了在Java堆和Native堆之间来回复制数据 2. HotSpot 虚拟机对象探秘 下面我们会深入浅出地探讨一下 HotSpot 虚拟机在 Java 堆 中对象分配、布局和访问的全过程 2.1. 对象的创建 当虚拟机遇到一条字节码 new 指令时，首先检查该指令的参数是否能在常量池中定位到一个类的符号引用，并坚持该类是否被加载、解析、初始化，如果没有去执行类加载过程 接下来虚拟机为新对象分配内存，实际上就是把一块确定大小的内存块从Java堆中划分出来 指针碰撞：Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间以一个指针作为分界点。分配内存的过程就是把该指针向空闲空间方向挪动一段距离 空闲链表：Java堆中内存并不是规整的，已被使用的内存和空闲的内存交错在一起，虚拟机必须维护一个列表进行记录。分配内存的过程就是从列表中找到一块足够大的内存划分给对象实例，并更新列表 Java堆是否规整 由垃圾收集器是否具备空间压缩整理的能力决定 在并发情况下指针或列表的修改并非线程安全的，这有两种可选方案： 对分配内存空间的操作进行同步处理 把内存分配的操作安装线程划分在不同的空间中进行，即所谓 本地线程分配缓冲(Thread Local Allocation Buffer, TLAB) 技术，每个线程现优先在本地缓冲区中分配内存，只有在本地缓冲区用完了，分配新的缓存区时才需要同步锁定 接下来虚拟机将分配到的内存空间初始化为零值 然后虚拟机会对对象进行必要的设置，例如：该对象属于哪个类、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息会存放在对象的 对象头(Object Header) 中 至此，从虚拟机视角来看，一个新的对象已经产生。而从Java程序视角来看，对象还需要执行 构造函数 ，即Class文件中的 ( ) 方法 2.2. 对象的内存布局 在 HotSpot 虚拟机里，对象在堆内存中的存储布局可划分为三部分：对象头(Header)、实例数据(Instance Data)、对其填充(Padding) 2.2.1. 对象头 对象头包含 运行时数据 和 类型指针 运行时数据：32位/64位，用于存储对象自身的运行时数据，例如：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。官方称其为 Mark Word 类型指针：对象指向它的类型元数据的指针，虚拟机通过该指针来确定该对象是哪个类的实例。 需要注意的是，并非所有的虚拟机实现都必须在对象数据上保留类型指针，也就是说，查找对象的元数据并不一定要经过对象本身 2.2.2. 实例数据 此部分是对象真正存储的有效信息，即对象中各种类型的字段内容，包括子类定义的和从父类继承的。 HotSpot 虚拟机默认的分配策略如下： 相同宽度的字段总是被分配到一起 在上述前提下，在父类中定义的变量会出现在子类之前 2.2.3. 对齐填充 没有特别含义，仅仅起占位符作用，因为 HotSpot 虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍 2.3. 对象的访问定位 Java程序会通过栈上的 reference 数据来操作堆上的具体数据。但是 reference 类型在《Java虚拟机规范》里只规定了它是一个指向对象的引用，所以对象的具体访问方式因虚拟机实现而异 使用句柄访问：从Java堆中划分出一块内存来作为句柄池，reference 中存储着对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息 使用直接指针访问：reference 直接存储着对象实例的地址，可以减少一次间接访问的开销。但是Java堆需要另外考虑如何放置访问类型数据的相关信息 出于访问速度的考虑，HotSpot 采用的是第二种方式进行对象访问 3. 实战：OutOfMemoryError异常 (略) By YangXin Xu            updated 2023-09-29 08:38:33 "},"第3章-垃圾收集器与内存分配策略.html":{"url":"第3章-垃圾收集器与内存分配策略.html","title":"第3章-垃圾收集器与内存分配策略","keywords":"","body":" By YangXin Xu            updated 2023-09-29 09:00:31 "}}