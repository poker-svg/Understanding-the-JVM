{"./":{"url":"./","title":"Introduction","keywords":"","body":"1. Introduction1. Introduction 这是我的《深入理解Java虚拟机》的读书笔记的gitbook，会时不时更新。 By YangXin Xu            updated 2023-09-28 18:37:33 "},"第1章-走进Java.html":{"url":"第1章-走进Java.html","title":"第1章-走进Java","keywords":"","body":"1. Java技术体系2. Java虚拟机家族2.1. 虚拟机始祖：Sun Classic/Exact VM2.2. 武林盟主2.3. 小家碧玉：Mobile/Embedded VM2.4. 天下第二：BEA JRockit/IBM J9 VM2.5. 软硬合璧：BEA Liquid VM/Azul VM2.6. 挑战者：Apache Harmony/Google Android Dalvik VM3. 实战：自己编译JDK3.1. 获取源码3.2. 系统需求3.3. 构建编译环境1. Java技术体系 Java技术体系可以分为以下四条主要的产品线： Java Card：支持Java小程序(Applets)运行在小内存设备(如智能卡)上的平台 Java ME(Micro Edition)：针对Java程序运行在移动终端上的平台，对Java API有所精简，并加入了移动终端的针对性支持 Java SE(Standard Edition)：支持面向桌面级应用的Java平台，提供了完整的Java核心API Java EE(Enterprise Edition)：支持使用多层架构的企业应用的Java平台，除了提供 Java SE API 外，还对其做了大量有针对性的扩充，并提供了相关的部署支持 2. Java虚拟机家族 2.1. 虚拟机始祖：Sun Classic/Exact VM Classic VM 只能使用纯解释器方式来执行Java代码，如果要使用即时编译器就必须进行外挂 Sun 提供的外挂编译器名为 sunwjit 。但是解释器和编译器不能配合、同时工作 JDK 1.2 时，曾在 Solaris 平台上发布过一款名为 Exact VM 虚拟机，它的编译执行系统已经具备现代高性能虚拟机的雏形，如：热点探测、两级即时编译器、编译器与解释器混合工作模式 等 Exact VM 因他使用 准确式内存管理(Exact Memory Management) 而得名：即虚拟机可以知道内存中某个位置的数据具体是什么类型 由于使用了准确式内存管理，Exact VM 可以抛弃以前 Classic VM 基于句柄的对象查找方式 2.2. 武林盟主 HotSpot 既继承了 Sun 之前两款商用虚拟机的优点，也有许多自己新的技术优势，如它名称中的 HotSpot (热点代码探测技术) 如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发 标准即时编译 和 栈上替换编译 行为 2.3. 小家碧玉：Mobile/Embedded VM Oracle 公司在Java ME这条产品线上的虚拟机名为 CDC-HI(Connected Device Configuration-Hotspot Implementation) 和 CLDC-HI(Connected Limited Device Configuration-Hotspot Implementation) CDC/CLDC 式一组在 JSR-139 和 JSR-218 规范中进行定义的Java API子集，这组规范希望在移动设备上建立统一的Java编程接口，上述两个虚拟机就是此组规范的参考实现 Java SE Embedded 里是 HotSpot 虚拟机，但为了适应嵌入式环境专门定制了裁剪的版本，尽可能在支持完整的 Java SE 功能的前提下向着减少内存消耗的方向优化 2.4. 天下第二：BEA JRockit/IBM J9 VM BEA System 公司的 JRockit 专注于服务端应用，因此其内部不包含解释器实现，全部代码依靠即时编译器编译后执行 JRockit 随着 BEA 被 Oracle 收购，现已不再继续发展，永远停留在 R28 版本 IBM J9 虚拟机的职责分离与模块化做得比 HotSpot 更优秀 2.5. 软硬合璧：BEA Liquid VM/Azul VM Liquid VM 也被称为 JRockit VE(Virtual Edition) ，它是BEA公司开发的可以直接运行在自家 Hypervisor 系统上的 JRockit 虚拟机的虚拟化版本 Liquid VM 本身不需要操作系统的支持，他自己实现了一个专用操作系统的必要功能，从而最大限度地发挥了硬件的能力，提升了Java程序的执行性能 Azul VM 是 Azul Systems 公司在 HotSpot 基础上进行大量改进，运行于自家 Vega 系统上的Java虚拟机 2.6. 挑战者：Apache Harmony/Google Android Dalvik VM Apache Harmony 是一个 Apache 软件基金会旗下以 Apache License 协议开源的实际兼容于JDK 5和JDK 6的Java程序运行平台，它含有自己的虚拟机和Java类库API Dalvik 虚拟机并不是一个Java虚拟机，它没有遵循《Java虚拟机规范》，不能直接执行Class文件。它使用的是寄存器架构而非常见的栈架构 Dalvik虚拟机曾是Android平台的核心组成部分之一，和Java有千丝万缕的联系： 它执行的DEX文件可以通过Class文件转换得来 它使用Java语法编写应用程序，可以直接使用绝大多数Java API 但是等到 Android 4.4 ，支持提前编译的ART虚拟机迅速崛起，并在 Android 5.0 里全面替代了 Dalvik 虚拟机 3. 实战：自己编译JDK 3.1. 获取源码 目前，OpenJDK 和 OracleJDK 代码实质上以达到完全一致的程度，所以我们编译的 OpenJDK 基本上可以认为性能、功能和执行逻辑上都和官方的 OracleJDK 是一致的 此次编译实践我们选择的版本是：OpenJDK 12 获取源码有以下两种方式： 直接从 repository 中 clone 源码到本地 从JDK的仓库中下载源码的压缩包 3.2. 系统需求 推荐在 Linux 或 MacOS 上构建 OpenJDK ，这两个系统在准备构建工具链和依赖项上要比在 Windows 或 Solaris 平台上要容易 原书作者使用的是 Ubuntu 18.04 LTS ，我用的是 CentOS 7 3.3. 构建编译环境 Linux 系统中需要使用 GCC 或 CLang 来编译，最低版本为 GCC 4.8 或 CLang 3.2，官方推荐版本为 GCC 7.8 或 CLang 9.1 OpenJDK 全部的依赖库如下所示 By YangXin Xu            updated 2023-09-28 20:06:40 "},"第2章-Java内存区域与内存溢出异常.html":{"url":"第2章-Java内存区域与内存溢出异常.html","title":"第2章-Java内存区域与内存溢出异常","keywords":"","body":"1. 运行时数据区域1.1. 程序计数器1.2. 本地方法栈1.3. Java堆1.4. 方法区1.5. 运行时常量池1.6. 直接内存2. HotSpot 虚拟机对象探秘2.1. 对象的创建2.2. 对象的内存布局2.2.1. 对象头2.2.2. 实例数据2.2.3. 对齐填充2.3. 对象的访问定位3. 实战：OutOfMemoryError异常1. 运行时数据区域 根据《Java虚拟机规范》，Java虚拟机所管理的内存将会包含如下几个运行时数据区域： 1.1. 程序计数器 程序计数器可以看作是当前线程所执行字节码的行号指示器，也是程序控制流的指示器 每条线程都会有一个独立的程序计数器，各条线程之间互不影响，独立存储 如果线程正在执行一个Java方法，PC记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地方法，PC值为空(Undefined) 1.2. 本地方法栈 本地方法栈和虚拟机栈所发挥的作用是非常相似的 虚拟机栈为虚拟机执行字节码服务 本地方法栈为虚拟机使用到的本地方法服务 1.3. Java堆 Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建 此内存区域仅存放 对象实例 。在《Java虚拟机规范》中对Java堆的描述是：”所有对象实例以及数组都应当在堆上分配“（如今这一点并不绝对） Java堆是 垃圾收集器 管理的内存区域，因此也被称为 GC堆 从分配内存的角度来看，所有线程共享的Java堆中可以划分出多个 线程私有的分配缓冲区 (Thread Local Allocation Buffer, TLAB) 。但任何划分Java堆的目的只是为了更好地回收内存、更快地分配内存。 Java堆的地址空间逻辑上连续，物理上可以处于不连续的内存空间中 Java堆既可以是固定大小的，也可以是可扩展的（主流） 1.4. 方法区 方法区也是各个线程共享的内存区域，用于存储已被虚拟机加载的 类型信息、常量、静态变量、即时编译器编译后的代码缓存 等数据 《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分。但方法区有个别名——“非堆” ，目的是与 Java堆 进行区分 方法区 和 永久代 并不等价： 由于 HotSpot 的流行，很多人将两者混为一谈，而这仅仅是因为当时的 HotSpot 虚拟机使用永久代来实现方法区 现在回过头来看，当年使用永久代来实现方法区的决定并不是一个好主意，因为这种设计导致了Java应用更容易遇到内存溢出的问题。甚至有极少数方法会因永久代的原因导致其在不同的虚拟机上有不同的表现 考虑到 HotSpot 未来的发展，在JDK 6的时候 HotSpot 开发团队就有放弃永久代，逐步改为采用本地内存来实现方法去的计划了，并最终于JDK 8完全废弃了永久代的概念 《Java虚拟机规范》对方法区的约束是非常宽松的。除了不需要连续的内存和可以选择固定大小或者可扩展外，甚至可以选择不实现垃圾收集 1.5. 运行时常量池 Class文件中包含 常量池表 ，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到 方法区的运行时常量池 中 运行时常量池 相对于 Class文件常量池 的另一个重要特征就是具备 动态性 。 Java语言并不要求常量一定只有在编译期才能产生，即Java程序运行期间也可以将新的常量放入池中 1.6. 直接内存 直接内存既不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域 JDK 1.4中新加入了 NIO 类，引入了一种基于 通道 与 缓冲区 的I/O方式，它可以使用 Native 函数库直接分配 堆外内存 ，然后通过一个存储在Java堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作 这种 直接内存 的机制能在一些场景中显著提高性能，因为它避免了在Java堆和Native堆之间来回复制数据 2. HotSpot 虚拟机对象探秘 下面我们会深入浅出地探讨一下 HotSpot 虚拟机在 Java 堆 中对象分配、布局和访问的全过程 2.1. 对象的创建 当虚拟机遇到一条字节码 new 指令时，首先检查该指令的参数是否能在常量池中定位到一个类的符号引用，并坚持该类是否被加载、解析、初始化，如果没有去执行类加载过程 接下来虚拟机为新对象分配内存，实际上就是把一块确定大小的内存块从Java堆中划分出来 指针碰撞：Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间以一个指针作为分界点。分配内存的过程就是把该指针向空闲空间方向挪动一段距离 空闲链表：Java堆中内存并不是规整的，已被使用的内存和空闲的内存交错在一起，虚拟机必须维护一个列表进行记录。分配内存的过程就是从列表中找到一块足够大的内存划分给对象实例，并更新列表 Java堆是否规整 由垃圾收集器是否具备空间压缩整理的能力决定 在并发情况下指针或列表的修改并非线程安全的，这有两种可选方案： 对分配内存空间的操作进行同步处理 把内存分配的操作安装线程划分在不同的空间中进行，即所谓 本地线程分配缓冲(Thread Local Allocation Buffer, TLAB) 技术，每个线程现优先在本地缓冲区中分配内存，只有在本地缓冲区用完了，分配新的缓存区时才需要同步锁定 接下来虚拟机将分配到的内存空间初始化为零值 然后虚拟机会对对象进行必要的设置，例如：该对象属于哪个类、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息会存放在对象的 对象头(Object Header) 中 至此，从虚拟机视角来看，一个新的对象已经产生。而从Java程序视角来看，对象还需要执行 构造函数 ，即Class文件中的 ( ) 方法 2.2. 对象的内存布局 在 HotSpot 虚拟机里，对象在堆内存中的存储布局可划分为三部分：对象头(Header)、实例数据(Instance Data)、对其填充(Padding) 2.2.1. 对象头 对象头包含 运行时数据 和 类型指针 运行时数据：32位/64位，用于存储对象自身的运行时数据，例如：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。官方称其为 Mark Word 类型指针：对象指向它的类型元数据的指针，虚拟机通过该指针来确定该对象是哪个类的实例。 需要注意的是，并非所有的虚拟机实现都必须在对象数据上保留类型指针，也就是说，查找对象的元数据并不一定要经过对象本身 2.2.2. 实例数据 此部分是对象真正存储的有效信息，即对象中各种类型的字段内容，包括子类定义的和从父类继承的。 HotSpot 虚拟机默认的分配策略如下： 相同宽度的字段总是被分配到一起 在上述前提下，在父类中定义的变量会出现在子类之前 2.2.3. 对齐填充 没有特别含义，仅仅起占位符作用，因为 HotSpot 虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍 2.3. 对象的访问定位 Java程序会通过栈上的 reference 数据来操作堆上的具体数据。但是 reference 类型在《Java虚拟机规范》里只规定了它是一个指向对象的引用，所以对象的具体访问方式因虚拟机实现而异 使用句柄访问：从Java堆中划分出一块内存来作为句柄池，reference 中存储着对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息 使用直接指针访问：reference 直接存储着对象实例的地址，可以减少一次间接访问的开销。但是Java堆需要另外考虑如何放置访问类型数据的相关信息 出于访问速度的考虑，HotSpot 采用的是第二种方式进行对象访问 3. 实战：OutOfMemoryError异常 (略) By YangXin Xu            updated 2023-09-29 08:38:33 "},"第3章-垃圾收集器与内存分配策略.html":{"url":"第3章-垃圾收集器与内存分配策略.html","title":"第3章-垃圾收集器与内存分配策略","keywords":"","body":"1. 概述2. 对象已死2.1. 引用计数算法2.2. 可达性分析算法2.3. 再谈引用2.4. 生存还是死亡2.5. 回收方法区3. 垃圾收集算法3.1. 分代收集理论3.2. 标记-清除算法3.3. 标记-复制算法3.4. 标记-整理算法4. HotSpot的算法细节实现4.1. 根节点枚举4.2. 安全点4.3. 安全区域4.4. 记忆集与卡表4.5. 写屏障1. 概述 1960年诞生于麻省理工学院的 Lisp 是第一门开始使用内存动态分配和垃圾收集技术的语言 现如今 内存动态分配 与 内存回收技术 已经相当成熟，但我们仍要了解垃圾收集和内存分配，因为当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就要对其进行必要的监控和调节 程序计数器、虚拟机栈、本地方法栈 三个区域随线程而生，随线程而灭，这几个区域的内存分配和回收具备确定性，因此无需过多考虑如何回收 Java堆、方法区 这两个区域具有很显著的不确定性，因此这部分内存的分配和回收时动态的。而垃圾收集器所关注的正是如何管理者部分内存 2. 对象已死 我们应当如何判断对象是“存活”着，还是已经“死去”？ 2.1. 引用计数算法 在对象中添加一个引用计数器 每当有一个地方引用它时，计数值就加一； 每当引用失效时，计数值就减一； 任何时刻计数器为零的对象就是不可再被使用的 引用计数算法虽占用了额外内存空间用以计数，但原理简单，判断效率很高 但主流的Java虚拟机都没有选用引用计数算法来管理内存。主要原因是：需要考虑很多例外情况（如循环引用），导致需要配合大量额外处理 2.2. 可达性分析算法 当前主流商用程序语言的内存管理子系统所选用的算法 将一系列称为 “GC Roots” 的根对象作为起始节点集，从这些节点开始根据引用关系向下搜索，走过的路径称为 “引用链” ，如果从 GC Roots 到某个对象不可达时，此对象不可再被使用 在Java技术体系里，固定 可作为 GC Roots 的对象包括： 在虚拟机栈中引用的对象 在方法区中类静态属性引用的对象 在方法区中常量引用的对象 在本地方法栈中 JNI 引用的对象 Java虚拟机内部的引用 所有被同步锁持有的对象 反映Java虚拟机内部情况的 JMXBean、JVMTI中注册的回调、本地代码缓存 等 2.3. 再谈引用 在JDK1.2之前，Java里面 引用 是很传统的定义：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该 reference 数据是代表某块内存、某个对象的引用 在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为 强引用、软引用、弱引用、虚引用 四种，其强度依次逐渐减弱 强引用：是最传统的引用定义，指在程序代码中普遍存在的引用赋值。无论任何情况下，只要强引用关系存在，垃圾收集器就永远不会回收掉被引用的对象 软引用：用来描述还有用但非必须的对象。如果某对象仅被软引用关联，在系统将要发生内存溢出溢出前，该对象会被列入回收范围进行第二次回收，如果内存还是不够，系统才会抛出内存溢出异常 弱引用：用来描述非必须对象。被弱引用关联的的对象只能生存道下一次垃圾收集发生为止 虚引用：又被称为 “幽灵引用” 或 “幻影引用”。一个对象是否具有虚引用，不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知 2.4. 生存还是死亡 即使在可达性分析算法中判定为不可达的对象，也不是非死不可的 如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记 随后进行筛选，筛选的条件是此对象是否有必要执行 finalize() 方法： 如果对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为没有必要执行 如果该对象有必要执行 finalize() 方法，那么虚拟机会将该对象塞入 F-Queue 队列中。Finalizer 线程会负责执行该队列中的对象的 finalize() 方法 垃圾收集器将会对 F-Queue 中的对象进行第二次小规模的标记，如果某对象在 finalize() 中自救成功了（重新和 GC Roots 建立起引用链），会被移出第二次标记的范围 最后两次都被标记的对象会被垃圾收集器回收 注意，在真实项目中，我们应尽量避免使用 finalize() 来进行自救，它并不等同于 C 或 C++ 中的析构函数 2.5. 回收方法区 相比于Java堆，对方法区进行垃圾收集的回收效果是比较低的 回收废弃常量：当一个常量没有被其他地方引用时，它就会被系统清理出常量池 回收不再使用的类型：当一个类型同时满足下面三个条件时，Java虚拟机 被允许 对此类型进行回收，是否真要回收，取决于是否配置有关参数 该类的所有实例都已被回收 加载该类的类加载器已被回收 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 3. 垃圾收集算法 垃圾收集算法的实现设计大量的程序细节，且各个平台的虚拟机操作内存的方法都有差异，此节我们重点介绍分代收集理论和几种算法思想及其发展过程 3.1. 分代收集理论 分代收集理论实质上是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上： 弱分代假说：绝大多数对象都是朝生夕灭的 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡 因此多款常用的垃圾收集器的一致的设计原则是：收集器应该将Java堆划分出不同的区域，然后将回收对象根据其年龄分配到不同的区域之中存储 把分代收集理论具体放到现在的商用Java虚拟机里，设计者一般至少会把Java堆划分为 新生代(Young Generation) 和 老年代(Old Generation) 两个区域 顾名思义，在新生代中，每次垃圾收集时都有大批对象死去，而每次回收后存活的少量对象将会逐步晋升到老年代中存放 分代收集理论的一大困难是 跨代引用 ： 假如现在进行一次只局限于新生代区域内的收集(Minor GC)，但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域内的存活对象，不得不在固定的 GC Roots 之外，再额外遍历整个老年代来确保可达性分析的正确性。而这种方式必然会给内存带来很大的性能负担，因此我们引入第三条经验法则： 跨代引用假说：跨代引用相对于同代引用来说仅占极少数 上述经验法则源自于此推论：存在相互引用关系的两个对象，是倾向于同生共死的 有了上述假说，我们就可以使用如下方法来减少开销： 在新生代上简历一个全局的 记忆集(Remembered Set) ，该数据结构将老年代划分为若干小块，并标识出老年代的哪一块内存存在跨代引用 此后发生 Minor GC 时，只有包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描 垃圾收集类型： 新生代收集(Minor GC/Young GC)：目标只是新生代的垃圾收集 老年代收集(Major GC/Old GC)：目标只是老年代的垃圾收集 混合收集(Mixed GC)：目标是包括整个新生代和部分老年代的垃圾收集 整堆收集(Full GC)：目标包含整个Java堆和方法区的垃圾收集 3.2. 标记-清除算法 1960年Lisp之父 John McCarthy 提出了 标记清除算法 该算法首先标记出所有需要回收的对象，随后统一回收掉所有被标记(或未被标记)的对象 后续的收集算法大多是以标记-清除算法为基础进行改进得到的 该算法有以下两个缺点： 执行效率不稳定，标记和清除两个过程的执行效率都会随对象数量增长而降低 标记、清除之后会产生大量不连续的内存碎片 3.3. 标记-复制算法 1969年 Fenichel 提出了一种称为 “半区复制” 的垃圾收集算法 该算法将可用内存划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面 优点：实现简单、运行高效；缺点：浪费空间，可用内存缩水一半 Appel式回收：一种更优化的半区复制分代策略 将 新生代 分为一块较大的 Eden 空间和两块较小的 Survivor 空间。HotSpot 默认 Eden 空间和 Survivor 空间的大小比例是 8:1 。 每次分配内存只使用 Eden 和其中一块 Survivor 。GC发生时，虚拟机会将 Eden 和 Survivor 中仍然存活的对象复制到另一块 Survivor 上，随后清空 Eden 和 Survivor 同时还存在一个充当罕见情况的 “逃生门”安全设计 ：当 Survivor 容纳不下一次 Minor GC 后存活的对象时，会依赖于其他内存区域（通常是老年代）进行 分配担保( Handle Promotion ) 3.4. 标记-整理算法 1974年 Edward Lueders 提出了另外一种有针对性的“标记-整理”算法：每次GC时将所有存活对象像内存空间的一端移动，然后直接清理掉边界以外的内存 移动存活对象并更新所有引用这些对象的地方将会是一种极为繁重的操作，而且这种操作也必须全程暂停用户应用程序才能进行 但是这种算法也很显著地改善了 内存碎片 问题 总结： 移动对象则内存回收会更复杂；不移动对象则内存分配会更复杂 移动对象会提升整个程序的吞吐量；不移动对象会减少程序运行的停顿时间 两者结合： 虚拟机平时多数时间采用 标记-清除算法 ，暂时容忍内存碎片的存在 当内存空间的碎片化程度已经达到影响对象分配时，再采用 标记-整理算法 GC一次，以获得规整的内存空间 4. HotSpot的算法细节实现 4.1. 根节点枚举 固定可作为 GC Roots 的节点主要存在于 全局性的引用 与 执行上下文 中。但令人遗憾的是，随着Java应用愈来愈庞大，仅方法区的大小就有成百上千兆，显然从此处开始查找耗费时间 迄今为止，可达性算法耗时最长的查找引用链过程已经可以做到与用户线程一起并发，但根节点枚举始终还是必须在一个 能保障一致性的快照 才得以进行 “一致性”：整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现在分析过程中根节点集合的对象引用关系还在不断变化的情况。这是导致垃圾收集过程必须 停顿所有用户线程 的其中一个重要原因 目前主流Java虚拟机使用的都是 准确式垃圾收集 ，所以当用户线程停顿下来后并不需要依次检查完所有的 全局性引用位置 和 执行上下文 ，虚拟机是有办法直接得到哪些地方存放着对象引用的 在 HotSpot 里存在一组 OopMap 数据结构，HotSpot 会在 类加载或者即时编译 的过程中，将 数据类型和引用信息 写入 OopMap 记录中，这样收集器在扫描时就可以直接得到这些信息了，而并不需要依次从方法区等 GC Roots 处开始查找 4.2. 安全点 在 OopMap 的协助下，HotSpot 可以快速准确地完成 GGC Roots 枚举 但是导师 OopMap 内容变化的指令非常多，如果为每条指令都生成对应的 OopMap 就会产生大量的额外存储空间占用 HotSpot 并没有为每条指令都生成 OopMap ，而只是在“特定的位置”记录这些信息，这些位置被称为安全点（Safepoint），用户程序必须执行抵达安全点后才能够暂停 安全点位置的选取基本上是以 “是否具有让程序长时间执行的特征” 为标准进行选定的： “长时间”执行最明显的特征是指令序列的复用，例如方法调用、循环跳转、异常跳转等都属于指令序列复用，因此只有具有这些功能的指令才会产生安全点 如何在GC发生时让所有线程都跑到最近的安全点后停顿下来，有以下两种方案： 抢占式中断：在GC发生时，系统将所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，直到它跑到安全点上再中断。现在 几乎没有 虚拟机使用这种方式 主动式中断：当GC发生时，系统会设置一个标志位，各个线程执行过程中会不断主动去轮询此标志，一旦发现中断标志为真就在最近的安全点主动中断挂起。 4.3. 安全区域 安全点机制保证了 程序执行 时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。但是，程序“不执行”的时候呢？（例如 Sleep 状态 或 Blocked 状态）此时线程无法响应虚拟机的中断请求，无法走到安全点去中断挂起自己。基于此问题我们引入了 安全区域( Safe Region ) 来解决 安全区域：能确保在某一段代码片段之中，引用关系不会发生变化，因此在该区域内进行GC是安全的。我们可以将安全区域看作被扩展拉伸了的安全点 用户线程进入安全区时，虚拟机在GC时就不会去管它；当GC没有结束时，处于安全区里的用户线程想要离开只能等待 4.4. 记忆集与卡表 记忆集：一种用于记录从 非收集区域 指向 收集区域 的指针集合的抽象数据结构 记忆集具有不同的记录粒度： 字长精度：每个记录精确到一个机器字长，该字包含跨代指针 对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针 卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针 第三种方式具体而言就是使用 “卡表” 的方式实现记忆集 HotSpot 将卡表实现为一个字节数组： CARD_TABLE[this_address >> 9] = 0; 字节数组 CARD_TABLE 的每个元素对应着内存区域中一块特定大小的内存块（被称为“卡页”）。只要卡页中有一个对象的字段存在跨代指针，卡表的对应元素就会标识为1，称该元素变脏( Dirty ) 4.5. 写屏障 By YangXin Xu            updated 2023-09-30 20:13:05 "}}