{"./":{"url":"./","title":"Introduction","keywords":"","body":"1. Introduction1. Introduction 这是我的《深入理解Java虚拟机》的读书笔记的gitbook，会时不时更新。 By YangXin Xu            updated 2023-09-28 18:37:33 "},"第1章-走进Java.html":{"url":"第1章-走进Java.html","title":"第1章-走进Java","keywords":"","body":"1. Java技术体系2. Java虚拟机家族2.1. 虚拟机始祖：Sun Classic/Exact VM2.2. 武林盟主2.3. 小家碧玉：Mobile/Embedded VM2.4. 天下第二：BEA JRockit/IBM J9 VM2.5. 软硬合璧：BEA Liquid VM/Azul VM2.6. 挑战者：Apache Harmony/Google Android Dalvik VM3. 实战：自己编译JDK3.1. 获取源码3.2. 系统需求3.3. 构建编译环境1. Java技术体系 Java技术体系可以分为以下四条主要的产品线： Java Card：支持Java小程序(Applets)运行在小内存设备(如智能卡)上的平台 Java ME(Micro Edition)：针对Java程序运行在移动终端上的平台，对Java API有所精简，并加入了移动终端的针对性支持 Java SE(Standard Edition)：支持面向桌面级应用的Java平台，提供了完整的Java核心API Java EE(Enterprise Edition)：支持使用多层架构的企业应用的Java平台，除了提供 Java SE API 外，还对其做了大量有针对性的扩充，并提供了相关的部署支持 2. Java虚拟机家族 2.1. 虚拟机始祖：Sun Classic/Exact VM Classic VM 只能使用纯解释器方式来执行Java代码，如果要使用即时编译器就必须进行外挂 Sun 提供的外挂编译器名为 sunwjit 。但是解释器和编译器不能配合、同时工作 JDK 1.2 时，曾在 Solaris 平台上发布过一款名为 Exact VM 虚拟机，它的编译执行系统已经具备现代高性能虚拟机的雏形，如：热点探测、两级即时编译器、编译器与解释器混合工作模式 等 Exact VM 因他使用 准确式内存管理(Exact Memory Management) 而得名：即虚拟机可以知道内存中某个位置的数据具体是什么类型 由于使用了准确式内存管理，Exact VM 可以抛弃以前 Classic VM 基于句柄的对象查找方式 2.2. 武林盟主 HotSpot 既继承了 Sun 之前两款商用虚拟机的优点，也有许多自己新的技术优势，如它名称中的 HotSpot (热点代码探测技术) 如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发 标准即时编译 和 栈上替换编译 行为 2.3. 小家碧玉：Mobile/Embedded VM Oracle 公司在Java ME这条产品线上的虚拟机名为 CDC-HI(Connected Device Configuration-Hotspot Implementation) 和 CLDC-HI(Connected Limited Device Configuration-Hotspot Implementation) CDC/CLDC 式一组在 JSR-139 和 JSR-218 规范中进行定义的Java API子集，这组规范希望在移动设备上建立统一的Java编程接口，上述两个虚拟机就是此组规范的参考实现 Java SE Embedded 里是 HotSpot 虚拟机，但为了适应嵌入式环境专门定制了裁剪的版本，尽可能在支持完整的 Java SE 功能的前提下向着减少内存消耗的方向优化 2.4. 天下第二：BEA JRockit/IBM J9 VM BEA System 公司的 JRockit 专注于服务端应用，因此其内部不包含解释器实现，全部代码依靠即时编译器编译后执行 JRockit 随着 BEA 被 Oracle 收购，现已不再继续发展，永远停留在 R28 版本 IBM J9 虚拟机的职责分离与模块化做得比 HotSpot 更优秀 2.5. 软硬合璧：BEA Liquid VM/Azul VM Liquid VM 也被称为 JRockit VE(Virtual Edition) ，它是BEA公司开发的可以直接运行在自家 Hypervisor 系统上的 JRockit 虚拟机的虚拟化版本 Liquid VM 本身不需要操作系统的支持，他自己实现了一个专用操作系统的必要功能，从而最大限度地发挥了硬件的能力，提升了Java程序的执行性能 Azul VM 是 Azul Systems 公司在 HotSpot 基础上进行大量改进，运行于自家 Vega 系统上的Java虚拟机 2.6. 挑战者：Apache Harmony/Google Android Dalvik VM Apache Harmony 是一个 Apache 软件基金会旗下以 Apache License 协议开源的实际兼容于JDK 5和JDK 6的Java程序运行平台，它含有自己的虚拟机和Java类库API Dalvik 虚拟机并不是一个Java虚拟机，它没有遵循《Java虚拟机规范》，不能直接执行Class文件。它使用的是寄存器架构而非常见的栈架构 Dalvik虚拟机曾是Android平台的核心组成部分之一，和Java有千丝万缕的联系： 它执行的DEX文件可以通过Class文件转换得来 它使用Java语法编写应用程序，可以直接使用绝大多数Java API 但是等到 Android 4.4 ，支持提前编译的ART虚拟机迅速崛起，并在 Android 5.0 里全面替代了 Dalvik 虚拟机 3. 实战：自己编译JDK 3.1. 获取源码 目前，OpenJDK 和 OracleJDK 代码实质上以达到完全一致的程度，所以我们编译的 OpenJDK 基本上可以认为性能、功能和执行逻辑上都和官方的 OracleJDK 是一致的 此次编译实践我们选择的版本是：OpenJDK 12 获取源码有以下两种方式： 直接从 repository 中 clone 源码到本地 从JDK的仓库中下载源码的压缩包 3.2. 系统需求 推荐在 Linux 或 MacOS 上构建 OpenJDK ，这两个系统在准备构建工具链和依赖项上要比在 Windows 或 Solaris 平台上要容易 原书作者使用的是 Ubuntu 18.04 LTS ，我用的是 CentOS 7 3.3. 构建编译环境 Linux 系统中需要使用 GCC 或 CLang 来编译，最低版本为 GCC 4.8 或 CLang 3.2，官方推荐版本为 GCC 7.8 或 CLang 9.1 OpenJDK 全部的依赖库如下所示 By YangXin Xu            updated 2023-09-28 20:06:40 "},"第2章-Java内存区域与内存溢出异常.html":{"url":"第2章-Java内存区域与内存溢出异常.html","title":"第2章-Java内存区域与内存溢出异常","keywords":"","body":"1. 运行时数据区域1.1. 程序计数器1.2. 本地方法栈1.3. Java堆1.4. 方法区1.5. 运行时常量池1.6. 直接内存2. HotSpot 虚拟机对象探秘2.1. 对象的创建2.2. 对象的内存布局2.2.1. 对象头2.2.2. 实例数据2.2.3. 对齐填充2.3. 对象的访问定位3. 实战：OutOfMemoryError异常1. 运行时数据区域 根据《Java虚拟机规范》，Java虚拟机所管理的内存将会包含如下几个运行时数据区域： 1.1. 程序计数器 程序计数器可以看作是当前线程所执行字节码的行号指示器，也是程序控制流的指示器 每条线程都会有一个独立的程序计数器，各条线程之间互不影响，独立存储 如果线程正在执行一个Java方法，PC记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地方法，PC值为空(Undefined) 1.2. 本地方法栈 本地方法栈和虚拟机栈所发挥的作用是非常相似的 虚拟机栈为虚拟机执行字节码服务 本地方法栈为虚拟机使用到的本地方法服务 1.3. Java堆 Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建 此内存区域仅存放 对象实例 。在《Java虚拟机规范》中对Java堆的描述是：”所有对象实例以及数组都应当在堆上分配“（如今这一点并不绝对） Java堆是 垃圾收集器 管理的内存区域，因此也被称为 GC堆 从分配内存的角度来看，所有线程共享的Java堆中可以划分出多个 线程私有的分配缓冲区 (Thread Local Allocation Buffer, TLAB) 。但任何划分Java堆的目的只是为了更好地回收内存、更快地分配内存。 Java堆的地址空间逻辑上连续，物理上可以处于不连续的内存空间中 Java堆既可以是固定大小的，也可以是可扩展的（主流） 1.4. 方法区 方法区也是各个线程共享的内存区域，用于存储已被虚拟机加载的 类型信息、常量、静态变量、即时编译器编译后的代码缓存 等数据 《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分。但方法区有个别名——“非堆” ，目的是与 Java堆 进行区分 方法区 和 永久代 并不等价： 由于 HotSpot 的流行，很多人将两者混为一谈，而这仅仅是因为当时的 HotSpot 虚拟机使用永久代来实现方法区 现在回过头来看，当年使用永久代来实现方法区的决定并不是一个好主意，因为这种设计导致了Java应用更容易遇到内存溢出的问题。甚至有极少数方法会因永久代的原因导致其在不同的虚拟机上有不同的表现 考虑到 HotSpot 未来的发展，在JDK 6的时候 HotSpot 开发团队就有放弃永久代，逐步改为采用本地内存来实现方法去的计划了，并最终于JDK 8完全废弃了永久代的概念 《Java虚拟机规范》对方法区的约束是非常宽松的。除了不需要连续的内存和可以选择固定大小或者可扩展外，甚至可以选择不实现垃圾收集 1.5. 运行时常量池 Class文件中包含 常量池表 ，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到 方法区的运行时常量池 中 运行时常量池 相对于 Class文件常量池 的另一个重要特征就是具备 动态性 。 Java语言并不要求常量一定只有在编译期才能产生，即Java程序运行期间也可以将新的常量放入池中 1.6. 直接内存 直接内存既不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域 JDK 1.4中新加入了 NIO 类，引入了一种基于 通道 与 缓冲区 的I/O方式，它可以使用 Native 函数库直接分配 堆外内存 ，然后通过一个存储在Java堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作 这种 直接内存 的机制能在一些场景中显著提高性能，因为它避免了在Java堆和Native堆之间来回复制数据 2. HotSpot 虚拟机对象探秘 下面我们会深入浅出地探讨一下 HotSpot 虚拟机在 Java 堆 中对象分配、布局和访问的全过程 2.1. 对象的创建 当虚拟机遇到一条字节码 new 指令时，首先检查该指令的参数是否能在常量池中定位到一个类的符号引用，并坚持该类是否被加载、解析、初始化，如果没有去执行类加载过程 接下来虚拟机为新对象分配内存，实际上就是把一块确定大小的内存块从Java堆中划分出来 指针碰撞：Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间以一个指针作为分界点。分配内存的过程就是把该指针向空闲空间方向挪动一段距离 空闲链表：Java堆中内存并不是规整的，已被使用的内存和空闲的内存交错在一起，虚拟机必须维护一个列表进行记录。分配内存的过程就是从列表中找到一块足够大的内存划分给对象实例，并更新列表 Java堆是否规整 由垃圾收集器是否具备空间压缩整理的能力决定 在并发情况下指针或列表的修改并非线程安全的，这有两种可选方案： 对分配内存空间的操作进行同步处理 把内存分配的操作安装线程划分在不同的空间中进行，即所谓 本地线程分配缓冲(Thread Local Allocation Buffer, TLAB) 技术，每个线程现优先在本地缓冲区中分配内存，只有在本地缓冲区用完了，分配新的缓存区时才需要同步锁定 接下来虚拟机将分配到的内存空间初始化为零值 然后虚拟机会对对象进行必要的设置，例如：该对象属于哪个类、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息会存放在对象的 对象头(Object Header) 中 至此，从虚拟机视角来看，一个新的对象已经产生。而从Java程序视角来看，对象还需要执行 构造函数 ，即Class文件中的 ( ) 方法 2.2. 对象的内存布局 在 HotSpot 虚拟机里，对象在堆内存中的存储布局可划分为三部分：对象头(Header)、实例数据(Instance Data)、对其填充(Padding) 2.2.1. 对象头 对象头包含 运行时数据 和 类型指针 运行时数据：32位/64位，用于存储对象自身的运行时数据，例如：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。官方称其为 Mark Word 类型指针：对象指向它的类型元数据的指针，虚拟机通过该指针来确定该对象是哪个类的实例。 需要注意的是，并非所有的虚拟机实现都必须在对象数据上保留类型指针，也就是说，查找对象的元数据并不一定要经过对象本身 2.2.2. 实例数据 此部分是对象真正存储的有效信息，即对象中各种类型的字段内容，包括子类定义的和从父类继承的。 HotSpot 虚拟机默认的分配策略如下： 相同宽度的字段总是被分配到一起 在上述前提下，在父类中定义的变量会出现在子类之前 2.2.3. 对齐填充 没有特别含义，仅仅起占位符作用，因为 HotSpot 虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍 2.3. 对象的访问定位 Java程序会通过栈上的 reference 数据来操作堆上的具体数据。但是 reference 类型在《Java虚拟机规范》里只规定了它是一个指向对象的引用，所以对象的具体访问方式因虚拟机实现而异 使用句柄访问：从Java堆中划分出一块内存来作为句柄池，reference 中存储着对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息 使用直接指针访问：reference 直接存储着对象实例的地址，可以减少一次间接访问的开销。但是Java堆需要另外考虑如何放置访问类型数据的相关信息 出于访问速度的考虑，HotSpot 采用的是第二种方式进行对象访问 3. 实战：OutOfMemoryError异常 (略) By YangXin Xu            updated 2023-09-29 08:38:33 "},"第3章-垃圾收集器与内存分配策略.html":{"url":"第3章-垃圾收集器与内存分配策略.html","title":"第3章-垃圾收集器与内存分配策略","keywords":"","body":"1. 概述2. 对象已死2.1. 引用计数算法2.2. 可达性分析算法2.3. 再谈引用2.4. 生存还是死亡2.5. 回收方法区3. 垃圾收集算法3.1. 分代收集理论3.2. 标记-清除算法3.3. 标记-复制算法3.4. 标记-整理算法4. HotSpot的算法细节实现4.1. 根节点枚举4.2. 安全点4.3. 安全区域4.4. 记忆集与卡表4.5. 写屏障4.6. 并发的可达性分析5. 经典垃圾收集器5.1. Serial收集器5.2. ParNew收集器5.3. Parallel Scavenge收集器5.4. Serial Old收集器5.5. Parallel Old收集器5.6. CMS收集器5.7. Garbage First收集器6. 低延迟垃圾收集器6.1. Shenandoah收集器6.2. ZGC收集器6.2.1. 内存布局6.2.2. 染色指针技术6.2.3. 多重映射技术7. 选择合适的垃圾收集器7.1. Epsilon收集器7.2. 收集器的权衡7.3. 虚拟机及垃圾收集器日志1. 概述 1960年诞生于麻省理工学院的 Lisp 是第一门开始使用内存动态分配和垃圾收集技术的语言 现如今 内存动态分配 与 内存回收技术 已经相当成熟，但我们仍要了解垃圾收集和内存分配，因为当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就要对其进行必要的监控和调节 程序计数器、虚拟机栈、本地方法栈 三个区域随线程而生，随线程而灭，这几个区域的内存分配和回收具备确定性，因此无需过多考虑如何回收 Java堆、方法区 这两个区域具有很显著的不确定性，因此这部分内存的分配和回收时动态的。而垃圾收集器所关注的正是如何管理者部分内存 2. 对象已死 我们应当如何判断对象是“存活”着，还是已经“死去”？ 2.1. 引用计数算法 在对象中添加一个引用计数器 每当有一个地方引用它时，计数值就加一； 每当引用失效时，计数值就减一； 任何时刻计数器为零的对象就是不可再被使用的 引用计数算法虽占用了额外内存空间用以计数，但原理简单，判断效率很高 但主流的Java虚拟机都没有选用引用计数算法来管理内存。主要原因是：需要考虑很多例外情况（如循环引用），导致需要配合大量额外处理 2.2. 可达性分析算法 当前主流商用程序语言的内存管理子系统所选用的算法 将一系列称为 “GC Roots” 的根对象作为起始节点集，从这些节点开始根据引用关系向下搜索，走过的路径称为 “引用链” ，如果从 GC Roots 到某个对象不可达时，此对象不可再被使用 在Java技术体系里，固定 可作为 GC Roots 的对象包括： 在虚拟机栈中引用的对象 在方法区中类静态属性引用的对象 在方法区中常量引用的对象 在本地方法栈中 JNI 引用的对象 Java虚拟机内部的引用 所有被同步锁持有的对象 反映Java虚拟机内部情况的 JMXBean、JVMTI中注册的回调、本地代码缓存 等 2.3. 再谈引用 在JDK1.2之前，Java里面 引用 是很传统的定义：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该 reference 数据是代表某块内存、某个对象的引用 在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为 强引用、软引用、弱引用、虚引用 四种，其强度依次逐渐减弱 强引用：是最传统的引用定义，指在程序代码中普遍存在的引用赋值。无论任何情况下，只要强引用关系存在，垃圾收集器就永远不会回收掉被引用的对象 软引用：用来描述还有用但非必须的对象。如果某对象仅被软引用关联，在系统将要发生内存溢出溢出前，该对象会被列入回收范围进行第二次回收，如果内存还是不够，系统才会抛出内存溢出异常 弱引用：用来描述非必须对象。被弱引用关联的的对象只能生存道下一次垃圾收集发生为止 虚引用：又被称为 “幽灵引用” 或 “幻影引用”。一个对象是否具有虚引用，不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知 2.4. 生存还是死亡 即使在可达性分析算法中判定为不可达的对象，也不是非死不可的 如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记 随后进行筛选，筛选的条件是此对象是否有必要执行 finalize() 方法： 如果对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为没有必要执行 如果该对象有必要执行 finalize() 方法，那么虚拟机会将该对象塞入 F-Queue 队列中。Finalizer 线程会负责执行该队列中的对象的 finalize() 方法 垃圾收集器将会对 F-Queue 中的对象进行第二次小规模的标记，如果某对象在 finalize() 中自救成功了（重新和 GC Roots 建立起引用链），会被移出第二次标记的范围 最后两次都被标记的对象会被垃圾收集器回收 注意，在真实项目中，我们应尽量避免使用 finalize() 来进行自救，它并不等同于 C 或 C++ 中的析构函数 2.5. 回收方法区 相比于Java堆，对方法区进行垃圾收集的回收效果是比较低的 回收废弃常量：当一个常量没有被其他地方引用时，它就会被系统清理出常量池 回收不再使用的类型：当一个类型同时满足下面三个条件时，Java虚拟机 被允许 对此类型进行回收，是否真要回收，取决于是否配置有关参数 该类的所有实例都已被回收 加载该类的类加载器已被回收 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 3. 垃圾收集算法 垃圾收集算法的实现设计大量的程序细节，且各个平台的虚拟机操作内存的方法都有差异，此节我们重点介绍分代收集理论和几种算法思想及其发展过程 3.1. 分代收集理论 分代收集理论实质上是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上： 弱分代假说：绝大多数对象都是朝生夕灭的 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡 因此多款常用的垃圾收集器的一致的设计原则是：收集器应该将Java堆划分出不同的区域，然后将回收对象根据其年龄分配到不同的区域之中存储 把分代收集理论具体放到现在的商用Java虚拟机里，设计者一般至少会把Java堆划分为 新生代(Young Generation) 和 老年代(Old Generation) 两个区域 顾名思义，在新生代中，每次垃圾收集时都有大批对象死去，而每次回收后存活的少量对象将会逐步晋升到老年代中存放 分代收集理论的一大困难是 跨代引用 ： 假如现在进行一次只局限于新生代区域内的收集(Minor GC)，但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域内的存活对象，不得不在固定的 GC Roots 之外，再额外遍历整个老年代来确保可达性分析的正确性。而这种方式必然会给内存带来很大的性能负担，因此我们引入第三条经验法则： 跨代引用假说：跨代引用相对于同代引用来说仅占极少数 上述经验法则源自于此推论：存在相互引用关系的两个对象，是倾向于同生共死的 有了上述假说，我们就可以使用如下方法来减少开销： 在新生代上简历一个全局的 记忆集(Remembered Set) ，该数据结构将老年代划分为若干小块，并标识出老年代的哪一块内存存在跨代引用 此后发生 Minor GC 时，只有包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描 垃圾收集类型： 新生代收集(Minor GC/Young GC)：目标只是新生代的垃圾收集 老年代收集(Major GC/Old GC)：目标只是老年代的垃圾收集 混合收集(Mixed GC)：目标是包括整个新生代和部分老年代的垃圾收集 整堆收集(Full GC)：目标包含整个Java堆和方法区的垃圾收集 3.2. 标记-清除算法 1960年Lisp之父 John McCarthy 提出了 标记清除算法 该算法首先标记出所有需要回收的对象，随后统一回收掉所有被标记(或未被标记)的对象 后续的收集算法大多是以标记-清除算法为基础进行改进得到的 该算法有以下两个缺点： 执行效率不稳定，标记和清除两个过程的执行效率都会随对象数量增长而降低 标记、清除之后会产生大量不连续的内存碎片 3.3. 标记-复制算法 1969年 Fenichel 提出了一种称为 “半区复制” 的垃圾收集算法 该算法将可用内存划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面 优点：实现简单、运行高效；缺点：浪费空间，可用内存缩水一半 Appel式回收：一种更优化的半区复制分代策略 将 新生代 分为一块较大的 Eden 空间和两块较小的 Survivor 空间。HotSpot 默认 Eden 空间和 Survivor 空间的大小比例是 8:1 。 每次分配内存只使用 Eden 和其中一块 Survivor 。GC发生时，虚拟机会将 Eden 和 Survivor 中仍然存活的对象复制到另一块 Survivor 上，随后清空 Eden 和 Survivor 同时还存在一个充当罕见情况的 “逃生门”安全设计 ：当 Survivor 容纳不下一次 Minor GC 后存活的对象时，会依赖于其他内存区域（通常是老年代）进行 分配担保( Handle Promotion ) 3.4. 标记-整理算法 1974年 Edward Lueders 提出了另外一种有针对性的“标记-整理”算法：每次GC时将所有存活对象像内存空间的一端移动，然后直接清理掉边界以外的内存 移动存活对象并更新所有引用这些对象的地方将会是一种极为繁重的操作，而且这种操作也必须全程暂停用户应用程序才能进行 但是这种算法也很显著地改善了 内存碎片 问题 总结： 移动对象则内存回收会更复杂；不移动对象则内存分配会更复杂 移动对象会提升整个程序的吞吐量；不移动对象会减少程序运行的停顿时间 两者结合： 虚拟机平时多数时间采用 标记-清除算法 ，暂时容忍内存碎片的存在 当内存空间的碎片化程度已经达到影响对象分配时，再采用 标记-整理算法 GC一次，以获得规整的内存空间 4. HotSpot的算法细节实现 4.1. 根节点枚举 固定可作为 GC Roots 的节点主要存在于 全局性的引用 与 执行上下文 中。但令人遗憾的是，随着Java应用愈来愈庞大，仅方法区的大小就有成百上千兆，显然从此处开始查找耗费时间 迄今为止，可达性算法耗时最长的查找引用链过程已经可以做到与用户线程一起并发，但根节点枚举始终还是必须在一个 能保障一致性的快照 才得以进行 “一致性”：整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现在分析过程中根节点集合的对象引用关系还在不断变化的情况。这是导致垃圾收集过程必须 停顿所有用户线程 的其中一个重要原因 目前主流Java虚拟机使用的都是 准确式垃圾收集 ，所以当用户线程停顿下来后并不需要依次检查完所有的 全局性引用位置 和 执行上下文 ，虚拟机是有办法直接得到哪些地方存放着对象引用的 在 HotSpot 里存在一组 OopMap 数据结构，HotSpot 会在 类加载或者即时编译 的过程中，将 数据类型和引用信息 写入 OopMap 记录中，这样收集器在扫描时就可以直接得到这些信息了，而并不需要依次从方法区等 GC Roots 处开始查找 4.2. 安全点 在 OopMap 的协助下，HotSpot 可以快速准确地完成 GGC Roots 枚举 但是导师 OopMap 内容变化的指令非常多，如果为每条指令都生成对应的 OopMap 就会产生大量的额外存储空间占用 HotSpot 并没有为每条指令都生成 OopMap ，而只是在“特定的位置”记录这些信息，这些位置被称为安全点（Safepoint），用户程序必须执行抵达安全点后才能够暂停 安全点位置的选取基本上是以 “是否具有让程序长时间执行的特征” 为标准进行选定的： “长时间”执行最明显的特征是指令序列的复用，例如方法调用、循环跳转、异常跳转等都属于指令序列复用，因此只有具有这些功能的指令才会产生安全点 如何在GC发生时让所有线程都跑到最近的安全点后停顿下来，有以下两种方案： 抢占式中断：在GC发生时，系统将所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，直到它跑到安全点上再中断。现在 几乎没有 虚拟机使用这种方式 主动式中断：当GC发生时，系统会设置一个标志位，各个线程执行过程中会不断主动去轮询此标志，一旦发现中断标志为真就在最近的安全点主动中断挂起。 4.3. 安全区域 安全点机制保证了 程序执行 时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。但是，程序“不执行”的时候呢？（例如 Sleep 状态 或 Blocked 状态）此时线程无法响应虚拟机的中断请求，无法走到安全点去中断挂起自己。基于此问题我们引入了 安全区域( Safe Region ) 来解决 安全区域：能确保在某一段代码片段之中，引用关系不会发生变化，因此在该区域内进行GC是安全的。我们可以将安全区域看作被扩展拉伸了的安全点 用户线程进入安全区时，虚拟机在GC时就不会去管它；当GC没有结束时，处于安全区里的用户线程想要离开只能等待 4.4. 记忆集与卡表 记忆集：一种用于记录从 非收集区域 指向 收集区域 的指针集合的抽象数据结构 记忆集具有不同的记录粒度： 字长精度：每个记录精确到一个机器字长，该字包含跨代指针 对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针 卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针 第三种方式具体而言就是使用 “卡表” 的方式实现记忆集 HotSpot 将卡表实现为一个字节数组： CARD_TABLE[this_address >> 9] = 0; 字节数组 CARD_TABLE 的每个元素对应着内存区域中一块特定大小的内存块（被称为“卡页”）。只要卡页中有一个对象的字段存在跨代指针，卡表的对应元素就会标识为1，称该元素变脏( Dirty ) 4.5. 写屏障 当有其它分代区域中的对象引用了本区域对象时，或者更准确地说，当某引用类型字段赋值的那一刻，我们应当去令对应的卡表元素变脏，从而维护卡表状态的时效性。但这显然很难做到完全同步 HotSpot 通过 写屏障 技术维护卡表状态。写屏障可以看作 在虚拟机层面对“引用类型字段赋值”这个动作的 AOP( Aspect Oriented Programming, 面向切面编程 ) 切面 在赋值前的部分的写屏障叫做 写前屏障 ，在复制后的则叫做 写后屏障 4.6. 并发的可达性分析 可达性分析算法理论上要求全过程都基于一个能保证一致性的快照中才能够进行分析。而全过程包括 根节点枚举 和 从根节点向下遍历对象图 由于 GC Roots 相比于整个Java堆中所有变量而言算是极少数，且在各种优化技巧加持下，它所带来的停顿已经是非常短暂且相对固定的（即不随堆容量而增长） 但是 从 GC Roots 向下遍历对象图 的停顿时间必然会与Java堆容量成正比例关系了 三色标记： 白色：表示对象尚未被垃圾收集器访问过 黑色：表示对象已被垃圾收集器访问过，且该对象的所有引用都已经扫描过 灰色：表示对象已经被垃圾收集器访问过，但该对象至少存在一个引用还没有被扫瞄过 Wilson 于1994年证明：当且仅当以下两个条件同时满足时，会产生 “对象消失“ 的问题，即原本应该是黑色的对象被误标为白色： 赋值器插入了若干条从黑色对象到白色对象的新引用 赋值器删除了全部从灰色对象到该白色对象的直接/间接引用 相对应的，我们有以下两种方式来解决并发扫描时的对象消失问题： 增量更新：当黑色对象插入新的指向白色对象的引用关系时，就将该插入引用记录下来。等并发扫描结束后，将这些记录过的引用关系中的黑色对象为根重新扫描一次 原始快照：当灰色对象要删除指向白色对象的引用关系时，就将该删除引用记录下来。并发扫描结束后，将这些记录过的引用关系中的灰色对象为根重新扫描一次 5. 经典垃圾收集器 下图展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用： 5.1. Serial收集器 Serial 收集器 是最基础、历史最悠久的收集器，曾经是 HotSpot 虚拟机新生代收集器的唯一选择 该收集器是一个 ”单线程“ 工作的收集器 这里的 ”单线程“ 并不仅仅是说它使用一条收集线程去完成GC工作，更重要的是强调它在GC时，需要暂停所有工作线程直到GC结束 下图示意了 Serial/Serial Old 收集器的运行过程： 从JDK 1.3一直到JDK 13+，从 Serial 收集器到 Parallel 收集器，再到 Concurrent Mark Sweep(CMS) 和 Garbage First(G1) 收集器，直至如今的 Shenandoah 和 ZGC 等，一个又一个构思精巧其复杂的垃圾收集器不断涌现。用户线程的停顿时间持续缩短但仍无法彻底消除 迄今为止，Serial 收集器仍是 HotSpot 运行在客户端模式下的默认新生代收集器，因为它有如下优点： 简单高效 对于内存资源首先环境，它额外内存消耗极小 对于单核或少核处理器环境，它由于没有线程交互开销，可以获得很高的单线程收集效率 5.2. ParNew收集器 ParNew 收集器实质上是 Serial 收集器的多线程并行版本，其工作过程如下图所示： 它是不少运行在服务端模式下的 HotSpot 虚拟机，尤其是JDK 7之前的遗留系统中首选的新生代收集器。其中一个很重要的原因是：除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作 JDK 5发布时，HotSpot 推出了划时代的 CMS 收集器，它是 HotSpot 第一款真正意义上支持并发的垃圾收集器。但遗憾的是， CMS 作为老年代的收集器，无法与JDK 1.4.0中的新生代收集器 Parallel Scavenge 配合工作 但随着更先进的G1收集器登场，G1是一个 面向全堆 的收集器，不再需要其它新生代收集器的配合，因此自JDK 9开始，ParNew + CMS 便不再是官方推荐的服务端模式下的收集器解决方案了 5.3. Parallel Scavenge收集器 吞吐量：处理器用于运行用户代码的实践与处理器总消耗时间的比值： $$ 吞吐量=\\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间} $$ Parallel Scavenge 收集器是一款新生代收集器，基于标记-复制算法，可以并行收集 其他收集器的关注点是尽可能缩短停顿时间，而此收集器的关注点是达到一个可控制的吞吐量，因此它也被称为 “吞吐量优先收集器” 良好的响应速度能提升用户体验 高吞吐量可以最高效率地利用处理器资源，主要适合在后台运算而无需太多交互的分析认为 5.4. Serial Old收集器 Serial Old 收集器 是 Serial 收集器 的老年代版本，是一个单线程收集器，基于标记-整理算法。它主要是供客户端模式下的 HotSpot 虚拟机使用。其工作过程如下图所示： 5.5. Parallel Old收集器 Parallel Old 收集器 是 Parallel Scavenge 收集器 的老年代版本，支持多线程，基于标记-整理算法 此收集器出现后，”吞吐量优先“收集器终于有了比较名副其实的搭配组合。在注重吞吐量或者处理器资源较为稀缺的场合，都可以考虑 Parallel Scavenge + Parallel Old 工作过程如下图所示： 5.6. CMS收集器 CMS(Concurrent Mark Sweep) 收集器 是一种以 获得最短停顿时间 为目标的收集器。它基于标记-清除算法。 它的运作过程分为四个步骤： 初始标记：需要 ”Stop The World“ 。此步骤仅是标记一下 GC Roots 能直接关联到的对象，速度很快； 并发标记：从 GC Roots 的直接关联对象开始遍历整个对象图，此过程耗时较长但无需停顿用户线程； 重新标记：需要 ”Stop The World“ 。此阶段是为了修正并发标记期间，因用户线程继续运行而导致标记发生变动的把部分对象的标记记录（实际上就是所谓的增量更新）。此过程停顿时间稍长一些； 并发清除：清理删除掉标记阶段判断为已死亡的对象，无需停顿； 它的工作过程如下图所示： 优点： 并发收集 低停顿 缺点： 对处理器资源非常敏感：因为它是面向并发设计的，所有会占用一部分处理器的计算资源而导致应用程序变慢，降低总吞吐量 无法处理“浮动垃圾”：因此可能会出现 “Con-curent Mode Failure” ，进而导致另一次完全 “Stop The World” 的 Full GC 产生 浮动垃圾：在CMS的并发标记和并非清理阶段，用户线程还在继续执行，自然会伴随有新的垃圾对象产生。这部分垃圾对象出现在标记过程结束后，CMS无法在这次的GC中处理它们，只能留到下一次GC在处理掉。这种垃圾即所谓 “浮动垃圾” 大量的空间碎片：因为CMS是基于标记清除算法实现的收集器。这会导致分配大对象时，明明老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，从而不得不提前触发一次 Full GC 5.7. Garbage First收集器 G1收集器是一个里程碑，他开创了收集器 面向局部收集 的设计思路和 基于 Region 的内存布局形式 G1是一款主要面向服务端的垃圾收集器。JDK 9发布后，G1宣告正式取代 Parallel Scavenge + Parallel Old ，称为服务端模式下的默认垃圾收集器 停顿时间模型：支持指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间大概率不超过N毫秒 在G1出现之前，GC的目标范围要么是整个新生代(Minor GC)，要么就是整个老年代(Major GC)，要么就是整个Java堆(Full GC)。而G1可以 面向堆内任何部分来组成回收集(Collection Set, CSet)进行回收 。衡量标准不再是它属于那个分代，而是那块内存中存放的垃圾数量最多，即所谓 Mixed GC 模式 G1将连续的Java堆划分为多个大小相等的独立区域(Region)，每个 Region 都可以根据需要来扮演 新生代的Eden空间、Survivor空间或者老年代空间 。而G1将 Region 作为单次回收的最小单元，从而可以有计划地避免 Full GC Region 中还有一类特殊的 Humongous 区域，专门用来存储大对象。G1的大多数行为都把 Humongous Region 作为老年代的一部分来看待 G1收集器的运作过程大致可划分为以下四个步骤： 初始标记：仅是标记 GC Roots 能直接关联到的对象，并修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确在可用 Region 中分配新对象。此阶段需要停顿 并发标记：从 GC Roots 开始对堆中对象进行可达性分析，递归扫描堆里的对象图，找出要回收的对象。此阶段耗时较长，但可与用户程序并发执行 最终标记：对用户线程做另一个短暂的暂停，用以处理并发阶段结束后仍遗留下来的最后那少量的SATB记录 筛选回收：负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个 Region 构成回收集，然后把回收集内的 Region 的存活对象复制到空 Region 中，在清理掉整个旧 Region 的全部空间。此阶段需停顿，由多条收集器线程并行完成 G1收集器运行示意图： 6. 低延迟垃圾收集器 衡量垃圾收集器的三项最重要的指标是：内存占用、吞吐量和延迟 。三者构成一个 “不可能三角” 下图展示了已接触过的垃圾收集器的停顿状况 浅色阶段表示必须挂起用户线程 深色阶段表示收集器线程和用户线程是并发工作的 6.1. Shenandoah收集器 由于 Shenandoah 是第一款不由Oracle公司的虚拟机团队所领导开发的 HotSpot 垃圾收集器，受到了官方的排挤，从而Oracle仍拒绝在OracleJDK中支持此收集器，执意在打包时完全排除了 Shenandoah 的代码。 最初 Shenandoah 是由 RedHat 公司独立发展的新型收集器项目，2014年 RedHat 将 Shenandoah 贡献给了OpenJDK，并推动它成为OpendJDK 12的正式特性之一，也就是后来的 JEP 189 Shenandoah 在管理堆内存方面，与G1至少有三个明显的不同之处： 支持并发的整理算法：G1的回收阶段可以多线程并行，却不能与用户线程并发 默认不使用分代收集：不会有专门的新生代Region或老年代Region的存在 摒弃了记忆集，改为使用 “连接矩阵” 来记录跨Region的引用关系：降低了处理跨代指针时的记忆集维护消耗，也降低了伪共存问题的发生概率 Shenandoah 收集器的工作过程可大致划分为以下9个阶段： 初始标记：与G1一样，标记与 GC Roots 直接关联的对象，此阶段会停顿，但时间长短只与 GC Roots 的数量相关 并发标记：与G1一样，遍历对象图，标记出全部可达的对象，此阶段与用户线程一起并发，时间长短取决于 堆中存活对象的数量 和 对象图的结构复杂程度 最终标记：与G1一样，处理剩余的SATN扫描，此阶段统计出回收价值最高的 Region ，将这些 Region 构成一组回收集。此阶段会有一小段的停顿 并发清理：此阶段用于清理那些整个区域一个存活对象都没有的 Region （这类 Region 被称为 Immediate Garbage Region） 并发回收：此阶段将回收集中的存活对象先复制一份到其他未被使用的Region之中，但是此阶段是和用户线程并发的，从而会存在移动对象的同时用户线程仍在读写移动对象。Shenandoah会通过 读屏障以及转发指针 来解决。此阶段时间长短取决于回收集大小 引用更新：并发回收阶段复制对象结束后，将堆中所有指针由旧对象的引用修正到复制后的新地址，此操作称为引用更新 初始引用更新：此阶段的目的只是为了建立一个线程集合点，确保所有并发回收阶段进行的收集器线程都完成分配给它们的对象移动任务而已 并发引用更新：此阶段开始进行引用更新操作，与用户线程并发，时间长短取决于内存中涉及的引用数量。并发引用更新无需沿对象图搜索，只需按物理地址顺序，线性搜索出引用类型并进行更新即可 最终引用更新：解决堆中引用更新后开始修正存在于 GC Roots 中的引用。需要停顿，时间长短取决于 GC Roots 的数量 并发清理：经过上述步骤，整个回收集中所有Region都没有存活对象，变为 Immediate Garbage Regions 。最后调用一次并发清理过程来回收它们 Shenandoah 收集器的工作过程如下： 6.2. ZGC收集器 ZGC(Z Garbage Collector) 是一款在JDK 11中新加入的具有实验性质的低延迟垃圾收集器 ZGC是一款基于Region内存布局的，（暂时）不设分代的，使用读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器 6.2.1. 内存布局 ZGC采用基于Region的堆内存布局，其Region具有动态性——动态创建和销毁，以及动态的区域容量大小 在x64硬件平台下，ZGC的Region可以具有如下的三类容量： 小型Region：容量固定为2MB，用于放置小于256KB的小对象 中型Region：容量固定为32MB，用于放置256KB~4MB的对象 大型Region：容量可动态变化（但必须为2MB的整数倍），用于放置4MB以上的大对象，而且每个大型Region只会存放一个大对象。大型Region在ZGC的实现中是不会被重分配的 6.2.2. 染色指针技术 染色指针是一种 直接将少量额外信息存储在指针上 的技术 在64位系统中，AMD架构只支持到52位的地址总线和48位的虚拟地址空间。此外OS一侧还会施加自己的约束，64位的Linux支持47位的进程虚拟地址空间和46位的物理地址空间；64位的Windows甚至只支持44位的物理地址空间 在Linux中，64位指针的高18位不用于寻址，但剩余46位的空间也足够满足大型服务器的需求了。于是ZGC的染色指针进一步盯上了剩余46位指针宽度：它将其高4位提取出来存储4个标志信息，单页进一步压缩地址空间至42位： 染色指针有一个前置问题：Java虚拟机作为一个普通进程，却如此随意重新定义指针的其中几位，OS是否支持？处理器是否支持？ 这个问题在Solaris/SPARC平台比较容易解决，因为SPARC硬件层面支持虚拟地址掩码；而x86-64平台则没有相关支持，因此只能使用虚拟内存映射技术进行补救 6.2.3. 多重映射技术 多重映射将多个不同的虚拟内存地址映射到同一个物理内存地址上。这意味着ZGC在虚拟内存中看到的地址空间比实际堆内存容量更大 从而我们可以将染色指针中的标志位看作是地址的分段符，再将不同的地址段映射到同一个物理内存空间，经过多次映射转换后，就可以使用染色指针正常进行寻址了 ZGC的运作过程如下所示： 7. 选择合适的垃圾收集器 7.1. Epsilon收集器 随着越来越复杂和先进的垃圾收集器相继出现，Epsilon作为一个“反其道而行”的新垃圾收集器出现在JDK 11的特征清单中 垃圾收集器的另一个别名为 自动内存管理子系统 ，因为它不仅要负责垃圾回收，还要负责 堆的管理与布局、对象的分配、与解释器的协作、与编译器的协作、与监控子系统协作等 从JDK 10开始，为了隔离 垃圾回收器 与 Java虚拟机解释、编译、监控等子系统 的关系，RedHat提出了垃圾收集器的统一接口（即JEP 304提案），而 Epsilon 是这个接口的有效性验证和参考实现 在实际生产环境中，运行负载极小、没有任何回收行为 的 Epsilon 便很适合微服务化、无服务化的发展方向 7.2. 收集器的权衡 垃圾收集器的选择主要受以下三个因素影响： 应用程序的主要关注点：吞吐量？延迟？内存占用？ 运行应用的基础设施：系统架构（x86-64/SPARC/ARM/Aarch64）、处理器数量、操作系统（Linux/Solaris/Windows） JDK的发行商和版本：ZingJDK/OracleJDK/Open-JDK/OpenJ9 7.3. 虚拟机及垃圾收集器日志 垃圾收集器日志是一系列人为设定的规则，没有“业界标准”可言 JDK 9时，HotSpot同意了日志处理框架，将其所有日志的功能都收归到 -Xlog 参数上： -Xlog[:[selector][:[output][:[decorators][:output-options]]]] By YangXin Xu            updated 2023-10-02 18:51:04 "},"第4章-虚拟机性能监控、故障处理工具.html":{"url":"第4章-虚拟机性能监控、故障处理工具.html","title":"第4章-虚拟机性能监控、故障处理工具","keywords":"","body":"1. 概述2. 基础故障处理工具2.1. jps：虚拟机进程状况工具2.2. jstat：虚拟机统计信息监视工具2.3. jinfo：Java配置信息工具2.4. jmap：Java内存映像工具2.5. jhat：虚拟机堆转储快照分析工具2.6. jstack：Java堆栈跟踪工具2.7. 基础工具总结3. 可视化故障处理工具3.1. JHSDB：基于服务性代理的调试工具3.2. JConsole：Java监视与管理控制台3.3. VisualVM：多合-故障处理工具3.4. Java Mission Control：可持续在线的监控工具4. HotSpot虚拟机插件及工具1. 概述 给一个系统定位问题的时候，知识、经验是关键基础，数据是依据，工具是运用知识处理数据的手段 。 恰当地使用虚拟机故障处理、 分析的工具可以提升我们分析数据、定位并解决问题的效率。 我们在学习工具前，应当意识到工具永远都是知识技能的一层包装，没有什么工具是“秘密武器”，拥有了就能“包治百病”。 2. 基础故障处理工具 随着JDK版本的更迭，Java的bin目录下的小工具的数量和功能在逐渐增加和增强。其场景范围包括 编译、运行、打包、部署、签名、监控、运维等： 这些工具根据软件可用性和授权的不同，可分为如下三类： 商业授权工具：主要是JMC（Java Mission Control）及它要使用到的JFR（Java Flight Recorder），JMC这个原本来自于JRockit的运维监控套件从JDK 7 Update 40开始就被集成到OracleJDK 中，JDK 11之前都无须独立下载，但是在商业环境中使用它则是要付费的。 正式支持工具：属于被长期支持的工具。 实验性工具：这一类工具在它们的使用说明中被声明为“没有技术支持，并且是实验性质的”产品，日后可能会转正，也可能会在某个JDK版本中无声无息地消失。但事实上它们通常都非常稳定而且功能强大，也能在处理应用程序性能问题、定位故障时发挥很大的作用。 2.1. jps：虚拟机进程状况工具 jps可以列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）。 对于本地虚拟机进程来说，LVMID与操作系统的进程ID（PID，Process Identifier）是一致的，使用Windows的任务管理器或者UNIX的ps命令也可以查询到虚拟机进程的LVMID，但如果同时启动了多个虚拟机进程，无法根据进程名称定位时，那就必须依赖jps命令显示主类的功能才能区分了。 jps命令格式： jps [ options ] [ hostid ] 2.2. jstat：虚拟机统计信息监视工具 jstat（JVM Statistics Monitoring Tool）：是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据。 jstat命令格式： jstat [ option vmid [interval[s|ms] [count]] ] vimd/lvimd：指定本地/远程虚拟机进程 interval：查询间隔 count：次数 option：用户希望查询的虚拟机信息，分为 类加载、垃圾收集、运行期编译状况 三类 jstat -gcutil 2764 S0 S1 E O P YGC YGCT FGC FGCT GCT 0.00 0.00 6.20 41.42 47.20 16 0.105 3 0.472 0.577 查询结果表明： 这台服务器的新生代Eden区（E，表示Eden）使用了6.2%的空间， 2个Survivor区 （S0、S1，表示Survivor0、Survivor1）里面都是空的， 老年代（O，表示Old）和永久代（P，表示 Permanent）则分别使用了41.42%和47.20%的空间。 程序运行以来共发生Minor GC（YGC，表示Young GC）16次，总耗时0.105秒； 发生Full GC（FGC，表示Full GC）3次，总耗时（FGCT，表示Full GC Time）为0.472秒； 所有GC总耗时（GCT，表示GC Time）为0.577秒。 2.3. jinfo：Java配置信息工具 jinfo（Configuration Info for Java）：用于实时查看和调整虚拟机各项参数。 jinfo [ option ] pid 2.4. jmap：Java内存映像工具 jmap（Memory Map for Java）：用于生成堆转储快照（一般称为heapdump或dump文件）。还可以查询finalize执行队列、Java堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等。 jmap [ option ] vmid 2.5. jhat：虚拟机堆转储快照分析工具 jhat（JVM Heap Analysis Tool）：一般与jmap搭配使用，来分析jmap生成的堆转储快照。 jhat内置了一个微型的HTTP/Web服务器，生成堆转储快照的分析结果后，可以在浏览器中查看。 一般不会在部署应用程序的服务器上直接分析堆转储快照，即使可以这样做，也会尽量将堆转储快照文件复制到其他机器上进行分析，因为分析工作是一个耗时而且极为耗费硬件资源的过程，既然都要在其他机器上进行，就没有必要再受命令行工具的限制了。 jhat的分析功能相对来说比较简陋，后文将会介绍到的VisualVM，以及专业用于分析堆转储快照文件的Eclipse Memory Analyzer、IBM HeapAnalyzer等工具，都能实现比jhat更强大专业的分析功能。 2.6. jstack：Java堆栈跟踪工具 jstack（Stack Trace for Java）：用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者 javacore文件）。 线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等，都是导致线程长时间停顿的常见原因。 jstack [ option ] vmid 2.7. 基础工具总结 下面表4-5～表4-14中罗列了JDK附带的全部（包括曾经存在但已经在最新版本中被移除的）工具及其简要用途： 3. 可视化故障处理工具 JDK中除了附带大量的命令行工具外，还提供了几个功能集成度更高的可视化工具，用户可以使用这些可视化工具以更加便捷的方式进行进程故障诊断和调试工作。这类工具主要包括JConsole、 JHSDB、VisualVM和JMC四个。 3.1. JHSDB：基于服务性代理的调试工具 3.2. JConsole：Java监视与管理控制台 3.3. VisualVM：多合-故障处理工具 3.4. Java Mission Control：可持续在线的监控工具 4. HotSpot虚拟机插件及工具 By YangXin Xu            updated 2023-10-09 14:31:47 "},"第5章-调优案例分析与实战.html":{"url":"第5章-调优案例分析与实战.html","title":"第5章-调优案例分析与实战","keywords":"","body":" By YangXin Xu            updated 2023-10-09 14:32:18 "},"第6章-类文件结构.html":{"url":"第6章-类文件结构.html","title":"第6章-类文件结构","keywords":"","body":"1. 无关性的基石2. Class类文件的结构2.1. 魔数与Class文件的版本2.2. 常量池2.3. 访问标志2.4. 类索引、父类索引与接口索引集合2.5. 字段表集合2.6. 方法表集合2.7. 属性表集合2.7.1. Code属性2.7.2. Exceptions属性2.7.3. LineNumberTable属性2.7.4. LocalVariableTable及LocalVariableTypeTable属性2.7.5. SourceFile及SourceDebugExtension属性2.7.6. Constant Value属性2.7.7. InnerClasses属性2.7.8. Deprecated及Synthetic属性2.7.9. StackMapTable属性2.7.10. Signature属性2.7.11. BootstrapMethods属性2.7.12. MethodParameters属性2.7.13. 模块化相关属性2.7.14. 运行时注解相关属性3. 字节码指令简介3.1. 字节码与数据类型3.2. 加载和存储指令3.3. 运算指令3.4. 类型转换指令3.5. 对象创建与指令访问3.6. 操作数栈管理指令3.7. 控制转移指令3.8. 方法调用和返回指令3.9. 异常处理指令3.10. 同步指令4. 公有设计，私有实现5. Class文件结构的发展1. 无关性的基石 各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式——字节码（Byte Code） 是构成平台无关性的基石。 Java虚拟机、字节码、编译器、源文件的关系如下所示： 字节码的语言表述能力比Java语言本身更加强大：Java语言中的各种语法、关键字、常量变量和运算符号的语义最终都会由多条字节码指令组合来表达，这决定了字节码指令所能提供的语言描述能力必须比Java语言本身更加强大才行。因此，有一 些Java语言本身无法有效支持的语言特性并不代表在字节码中也无法有效表达出来，这为其他程序语言实现一些有别于Java的语言特性提供了发挥空间。 2. Class类文件的结构 注意 任何一个Class文件都对应着唯一的一个类或接口的定义信息，但是反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。 Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符。 这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储。 Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”。 无符号数：属于基本的数据类型，包括u1、u2、u4、u8，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。 表：由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表的命名都习惯性地以“_info”结尾。 Class文件结构： 2.1. 魔数与Class文件的版本 Class文件的头四个字节被称为 魔数（Magic Number） ，它的唯一作用是确定这个文件是否为一个被虚拟机接受的Class文件。 紧接着魔数的4个字节存储的是 Class文件的版本号 ：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。 2.2. 常量池 紧邻着主、次版本号之后的是常量池入口。 在常量池的入口会放置一项u2类型的常量池容量计数值（constant_pool_count）。该容量计数比较特殊，是从1而不是0开始的。 Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始。 常量池主要存放以下两大类常量： 字面量：它比较接近于Java语言层面的常量概念，如 文本字符串 、被声明为final的常量值 等。 符号引用：它属于编译原理方面的概念，主要包括下面几类常量： 被模块导出或者开放的包（Package） 类和接口的全限定名（Fully Qualified Name） 字段的名称和描述符（Descriptor） 方法的名称和描述符 ·方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic） 动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant） 常量池中每一项常量都是一个表。截至 JDK 13 ，常量表中共有如下17种不同类型的常量： 在JDK的bin目录中，Oracle公司为我们准备好一个专门用于分析Class文件字节码的工具：javap 2.3. 访问标志 在常量池结束之后，紧接着的2个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息： 2.4. 类索引、父类索引与接口索引集合 类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定该类型的继承关系。 类索引用于确定这个类的全限定名； 父类索引用于确定这个类的父类的全限定名； 接口索引集合就用来描述这个类实现了哪些接口； 对于类索引和父类索引，它们的查找过程如下所示： 对于接口索引集合，由于其数量不定，因此其入口的第一项u2类型的数据为接口计数器（interfaces_count），随后紧跟着的是所有接口的索引。 2.5. 字段表集合 字段表（field_info）用于描述接口或者类中声明的变量（字段）。 access_flags：字段的访问修饰符，其中可设置的标志位和含义如下表所示 name_index：字段简单名称的常量池索引。 descriptor_index：字段和方法的描述符的常量池索引。它是用来描述 字段的数据类型 、方法的参数列表和返回值。其中： 基本数据类型 以及代表无返回值的 void类型 都用一个大写字符来表示。 对象类型 则用字符L加对象的全限定名来表示。 数组类型：每一维度将使用一个前置的“[”字符来描述 方法类型：按照 先参数列表、后返回值 的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。 attribute_info：段表可以在属性表中附加描述零至多项的额外信息。 2.6. 方法表集合 class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，如下表所示： 这些数据项目的含义也与字段表中的非常类似，仅在访问标志和属性表集合的可选项中有所区别。 方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面。 正是因为返回值不会包含在特征签名之中，所以Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。 2.7. 属性表集合 Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。 与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格顺序。 并且《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。 《Java虚拟机规范》预定义的属性： 属性表结构： 2.7.1. Code属性 Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内。 Code属性出现在方法表的属性集合之中（但是接口或抽象类中的方法不存在Code属性） attribute_name_index：指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”。 attribute_length：指示属性值的长度。 max_stack：代表操作数栈深度的最大值。 max_locals：代表局部变量表所需的存储空间，单位为变量槽。 变量槽是虚拟机为局部变量分配内存所使用的最小单位。对于长度不超过32位的数据类型，每个局部变量占用一个变量槽，而double和long这两种64位的数据类型则需要两个变量槽来存放。 code_length：代表字节码指令长度。 code：用于存储字节码指令的一系列字节流。 exception_table_length：异常表长度。 exception_table：异常表，其格式如下： 当字节码从第start_pc行到第end_pc行之间（不含第end_pc行）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续处理。当catch_type的值为0时，代表任意异常情况都需要转到handler_pc处进行处理。 异常表实际上是Java代码的一部分，《Java虚拟机规范》中明确要求Java语言的编译器应当选择使用异常表而不是通过跳转指令来实现Java异常及finally处理机制。 2.7.2. Exceptions属性 Exceptions属性：用来列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在throws关键字后面列举的异常。 2.7.3. LineNumberTable属性 LineNumberTable属性：用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。 这个属性在字节码中不是必须生成的，如果选择不生成，则当抛出异常时，堆栈中不会显示出错的源代码行号；而且无法设置断点。 2.7.4. LocalVariableTable及LocalVariableTypeTable属性 LocalVariableTable属性：用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系。 这个属性在字节码中不是必须生成的，如果选择不生成，其他人引用这个方法时，所有的参数名称都将会丢失，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。 start_pc：局部变量的生命周期开始的字节码偏移量。 length：局部变量用范围覆盖的长度。 name_index：指向常量池中CONSTANT_Utf8_info型常量的索引，代表局部变量的名称。 descriptor：指向常量池中CONSTANT_Utf8_info型常量的索引，代表局部变量的描述符。 index：局部变量在栈帧的局部变量表中变量槽的位置。这个变量数据类型是64位类型时，它占用的变量槽为index和index+1两个。 2.7.5. SourceFile及SourceDebugExtension属性 SourceFile属性：用于记录生成这个Class文件的源码文件名称。 这个属性也是可选的，如果不生成的话，抛出异常时，堆栈中将不会显示出错代码所属的文件名。 sourcefile_index：指向常量池中CONSTANT_Utf8_info型常量的索引，常量值是源码文件的文件名。 SourceDebugExtension属性：为了方便在编译器和动态生成的Class中加入供程序员使用的自定义内容而引入的，用于存储额外的代码调试信息。 debug_extension：存储额外的调试信息，是一组通过变长UTF-8格式来表示的字符串。 2.7.6. Constant Value属性 ConstantValue属性：用于通知虚拟机自动为静态变量赋值。 非static类型的变量（也就是实例变量）的赋值是在实例构造器\\()方法中进行的； 对于类变量，则有两种方式可以选择：在类构造器\\()方法中或者使用ConstantValue属性； 如果同时使用final和static来修饰一个变量，并且这个变量的数据类型是基本类型或者java.lang.String的话，就将会生成ConstantValue属性来进行初始化； 如果这个变量没有被final修饰，或者并非基本类型及字符串，则将会选择在\\()方法中进行初始化； 上面是Oracle公司实现的Javac编译器的选择。 2.7.7. InnerClasses属性 InnerClasses属性：用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。 number_of_classes：代表需要记录多少个内部类信息。每个内部类信息都由一个inner_classes_info表进行描述。 inner_classes： inner_class_info_index：指向常量池中CONSTANT_Class_info型常量的索引，代表内部类的符号引用。 outer_class_info_index：指向常量池中CONSTANT_Class_info型常量的索引，代表宿主类的符号引用。 inner_name_index：指向常量池中CONSTANT_Utf8_info型常量的索引，代表这个内部类的名称，如果是匿名内部类，这项值为0。 inner_class_access_flags：是内部类的访问标志，它的取值范围如下表所示： 2.7.8. Deprecated及Synthetic属性 Deprecated属性：用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过代码中使用“@deprecated”注解进行设置。 Synthetic属性：代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的。 编译器通过生成一些在源代码中不存在的Synthetic方法、字段甚至是整个类的方式，实现了越权访问（越过private修饰器）或其他绕开了语言限制的功能，这可以算是一种早期优化的技巧。 attribute_length数据项的值必须为0，因为没有任何属性值需要设置。 2.7.9. StackMapTable属性 StackMapTable属性：在JDK 6增加到Class文件规范之中，是一个相当复杂的变长属性，位于Code属性的属性表中。该属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（TypeChecker）使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。 StackMapTable属性中包含零至多个栈映射帧（Stack Map Frame），每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示执行到该字节码时局部变量表和操作数栈的验证类型。 类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一段字节码指令是否符合逻辑约束。 2.7.10. Signature属性 Signature属性：在JDK 5增加到Class文件规范之中，它是一个可选的定长属性，可以出现于类、字段表和方法表结构的属性表中。在JDK 5里面大幅增强了Java语言的语法，在此之后，任何类、接口、初始化方法或成员的泛型签名如果包含了 类型变量或参数化类型 ，则Signature属性会为它记录泛型签名信息。 注：Java语言的泛型采用的是擦除法实现的伪泛型，字节码（Code属性）中所有的泛型信息在编译后都通通被擦除掉。 好处：实现简单、非常容易实现Backport，运行期也能够节省一些类型所占的内存空间。 坏处：运行期无法支持真泛型——将泛型类型与用户定义的普通类型同等对待。Signature属性就是为了弥补这个缺陷而增设的。 signature_index：一个对CONSTANT_Utf8_info常量池的索引，表示类签名或方法类型签名或字段类型签名。 2.7.11. BootstrapMethods属性 BootstrapMethods属性：在JDK 7时增加到Class文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。此属性用于保存invokedynamic指令引用的引导方法限定符。 num_bootstrap_methods：给出了bootstrap_methods[]数组中的引导方法限定符的数量。 bootstrap_methods[]：数组的每个成员包含了一个指向常量池CONSTANT_MethodHandle结构的索引值，它代表了一个引导方法 bootstrap_method_ref：一个指向常量池中CONSTANT_MethodHandle_info结构的索引。 num_bootstrap_arguments：其值给出了bootstrap_argu-ments[]数组成员的数量。 bootstrap_arguments[]：数组的每个成员是一个对常量池的有效索引。常量池在该索引出必须是下列结构之一：CONSTANT_String_info、CONSTANT_Class_info、CONSTANT_Integer_info、CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_MethodHandle_info或CONSTANT_MethodType_info。 2.7.12. MethodParameters属性 MethodParameters属性：在JDK 8时新加入到Class文件格式中，它是一个用在方法表中的变长属性。其作用是记录方法的各个形参名称和信息。 JDK 8中新增的这个属性，使得编译器可以（编译时加上-parameters参数）将方法名称也写进Class文件中，而且MethodParameters是方法表的属性，与Code属性平级的，可以运行时通过反射API获取。 name_index：是一个指向常量池CONSTANT_Utf8_info常量的索引值，代表了该参数的名称。 access_flags：参数的状态指示器，它可以包含以下三种状态中的一种或多种： 0x0010（ACC_FINAL）：表示该参数被final修饰。 0x1000（ACC_SYNTHETIC）：表示该参数并未出现在源文件中，是编译器自动生成的。 0x8000（ACC_MANDATED）：表示该参数是在源文件中隐式定义的。Java语言中的典型场景是this关键字。 2.7.13. 模块化相关属性 JDK 9的一个重量级功能是Java的模块化功能，因为模块描述文件（module-info.java）最终是要编译成一个独立的Class文件来存储的，所以，Class文件格式也扩展了Module、ModulePackages和ModuleMainClass三个属性用于支持Java模块化相关功能。 Module属性 Module属性：是一个非常复杂的变长属性，除了表示该模块的名称、版本、标志信息以外，还存储了这个模块requires、exports、opens、uses和provides定义的全部内容。 module_name_index：是一个指向常量池CONSTANT_Utf8_info常量的索引值，代表了该模块的名称。 module_flags：模块的状态指示器，它可以包含以下三种状态中的一种或多种： 0x0020（ACC_OPEN）：表示该模块是开放的。 0x1000（ACC_SYNTHETIC）：表示该模块并未出现在源文件中，是编译器自动生成的。 0x8000（ACC_MANDATED）：表示该模块是在源文件中隐式定义的。 module_version_index：是一个指向常量池CONSTANT_Utf8_info常量的索引值，代表了该模块的版本号。 requires、exports、opens、uses和provides：相似，略。 ModulePackages属性 ModulePackages属性：是另一个用于支持Java模块化的变长属性，它用于描述该模块中所有的包，不论是不是被export或者open的。 package_count属性：package_index数组的计数器。 package_index属性：其中每个元素都是指向常量池CONSTANT_Package_info常量的索引值，代表了当前模块中的一个包。 ModuleMainClass属性 ModuleMainClass属性：是一个定长属性，用于确定该模块的主类（Main Class）。 2.7.14. 运行时注解相关属性 早在JDK 5时期，Java语言的语法进行了多项增强，其中之一是提供了对注解（Annotation）的支持。为了存储源码中注解信息，Class文件同步增加了RuntimeVisibleAnnotations、RuntimeInvisibleAnnotations、RuntimeVisibleParameterAnnotations和RuntimeInvisibleParameter-Annotations四个属性。到了JDK 8时期，进一步加强了Java语言的注解使用范围，又新增类型注解（JSR 308），所以Class文件中也同步增加了RuntimeVisibleTypeAnnotations和RuntimeInvisibleTypeAnnotations两个属性。由于这六个属性不论结构还是功能都比较雷同，自己去翻手册吧，不赘述了。 3. 字节码指令简介 Java虚拟机的指令=单字节的操作码（Opcode）+不定长的操作数（Operand） 由于Java虚拟机采用面向操作数栈而不是面向寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码，指令参数都存放在操作数栈中。 由于限制了Java虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不能够超过256条。 但一个字节来代表操作码，也是为了尽可能获得短小精干的编译代码。 Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机在处理那些超过一个字节的数据时，不得不在运行时从字节中重建出具体数据的结构。在某种程度上这会导致解释执行字节码时将损失一些性能。 但放弃了操作数长度对齐，就意味着可以省略掉大量的填充和间隔符号 3.1. 字节码与数据类型 对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务： i代表int l代表long s代表short b代表byte c代表char f代表float d代表double a代表reference 因为Java虚拟机的操作码长度只有一字节，Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它，即指令集将会被故意设计成非完全独立的。 下表列举了Java虚拟机所支持的与数据类型相关的字节码指令： 编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。 因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的对int类型作为运算类型（Computational Type）来进行的。 3.2. 加载和存储指令 将一个局部变量加载到操作栈：iload、iload_\\、lload、lload_\\、fload、fload_\\、dload、dload_\\、aload、aload_\\ 将一个数值从操作数栈存储到局部变量表：istore、istore_\\、lstore、lstore_\\、fstore、fstore_\\、dstore、dstore_\\、astore、astore_\\ 将一个常量加载到操作数栈：bipush、sipush、ldc、ldcw、ldc2_w、aconst_null、iconst_m1、iconst\\\\、lconst_\\、fconst_\\、dconst_\\ 扩充局部变量表的访问索引的指令：wide 3.3. 运算指令 加法指令：iadd、ladd、fadd、dadd 减法指令：isub、lsub、fsub、dsub 乘法指令：imul、lmul、fmul、dmul 除法指令：idiv、ldiv、fdiv、ddiv 求余指令：irem、lrem、frem、drem 取反指令：ineg、lneg、fneg、dneg 位移指令：ishl、ishr、iushr、lshl、lshr、lushr 按位或指令：ior、lor·按位与指令：iand、land 按位异或指令：ixor、lxor 局部变量自增指令：iinc 比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp 3.4. 类型转换指令 宽化类型转换： int类型到long、float或者double类型 long类型到float、double类型 float类型到double类型 窄化类型转换：假如Java虚拟机将一个浮点值窄化转换为整数类型T： 如果浮点值是NaN，那转换结果就是int或long类型的0。 如果浮点值不是无穷大的话，浮点值使用IEEE 754的向零舍入模式取整，获得整数值v。如果v在目标类型T（int或long）的表示范围之类，那转换结果就是v；否则，将根据v的符号，转换为T所能表示的最大或者最小正数。 3.5. 对象创建与指令访问 虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。 创建类实例的指令：new 创建数组的指令：newarray、anewarray、multianewarray 访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload 将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore 取数组长度的指令：arraylength 检查类实例类型的指令：instanceof、checkcast 3.6. 操作数栈管理指令 将操作数栈的栈顶一个或两个元素出栈：pop、pop2 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2 将栈最顶端的两个数值互换：swap 3.7. 控制转移指令 条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne 复合条件分支：tableswitch、lookupswitch 无条件分支：goto、goto_w、jsr、jsr_w、ret 3.8. 方法调用和返回指令 invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。 invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。 invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。 invokestatic指令：用于调用类静态方法（static方法）。 invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。 3.9. 异常处理指令 在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现。 在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用jsr和ret指令来实现，现在已经不用了），而是采用异常表来完成。 3.10. 同步指令 Java虚拟机可以支持 方法级的同步和方法内部一段指令序列的同步 ，这两种同步结构都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的。 方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。 同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义。 4. 公有设计，私有实现 任何一款Java虚拟机实现都必须能够读取Class文件并精确实现包含在其中的Java虚拟机代码的语义。 但一个优秀的虚拟机实现，在满足《Java虚拟机规范》的约束下对具体实现做出修改和优化也是完全可行的，并且《Java虚拟机规范》中明确鼓励实现者这样去做。 只要优化以后Class文件依然可以被正确读取，并且包含在其中的语义能得到完整保持，那实现者就可以选择以任何方式去实现这些语义。 虚拟机在后台如何处理Class文件完全是实现者自己的事情，只要它在外部接口上看起来与规范描述的一致即可。 虚拟机的实现方式主要有以下两种： 将输入的Java虚拟机代码在加载时或执行时翻译成另一种虚拟机的指令集； 将输入的Java虚拟机代码在加载时或执行时翻译成宿主机处理程序的本地指令集； 5. Class文件结构的发展 Class文件结构自《Java虚拟机规范》初版订立以来，已经有超过二十年的历史。这二十多年间，Java技术体系有了翻天覆地的改变，JDK的版本号已经从1.0提升到了13。 相对于语言、API以及Java技术体系中其他方面的变化，Class文件结构一直处于一个相对比较稳定的状态，Class文件的主体结构、字节码指令的语义和数量几乎没有出现过变动。 所有对Class文件格式的改进，都集中在访问标志、属性表这些设计上原本就是可扩展的数据结构中添加新内容。 Class文件格式所具备的平台中立（不依赖于特定硬件及操作系统）、紧凑、稳定和可扩展的特点，是Java技术体系实现平台无关、语言无关两项特性的重要支柱。 By YangXin Xu            updated 2023-10-10 00:29:11 "},"第7章-虚拟机类加载机制.html":{"url":"第7章-虚拟机类加载机制.html","title":"第7章-虚拟机类加载机制","keywords":"","body":"1. 概述2. 类加载的时机3. 类加载的过程3.1. 加载3.2. 验证3.2.1. 文件格式验证3.2.2. 元数据验证3.2.3. 字节码验证3.2.4. 符号引用验证3.3. 准备3.4. 解析3.4.1. 类或接口的解析3.4.2. 字段解析3.4.3. 方法解析3.4.4. 接口方法解析3.5. 初始化4. 类加载器4.1. 类与类加载器4.2. 双亲委派机制5. Java模块化系统5.1. 模块的兼容性5.2. 模块化下的类加载器1. 概述 虚拟机的类加载机制：Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。 Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让Java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为Java应用提供了极高的扩展性和灵活性。 2. 类加载的时机 上述表示的是按部就班地“开始”，而非按部就班地“进行”或按部就班地“完成”。因为这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。 《Java虚拟机规范》并没有强制约束何时开始类的“加载”。但严格规定了有且只有如下六种情况必须立即对类进行“初始化“，他们被称为 对一个类进行主动引用 。 遇到 new、getstatic、putstatic或invokestatic 这四条字节码指令时。 使用java.lang.reflect包的方法对类型进行反射调用的时候。 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。 被动引用的三个例子： 通过子类引用父类的静态字段，不会导致子类初始化。 通过数组定义来引用类，不会触发此类的初始化。 常量在编译阶段会存入类的常量池，和类脱离，因此访问该常量也不会触发此类初始化。 接口初始化过程的特殊性： 接口中不能使用 ”static{}“ 语句块，但编译器仍然会为接口生成 \\() 类构造器，用以初始化接口中定义的成员变量。 当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。 3. 类加载的过程 类加载 = 加载 + 验证 + 准备 + 解析 + 初始化 3.1. 加载 在加载阶段，虚拟机需要完成以下三件事： 通过一个类的全限定名来获取定义此类的二进制字节流。 将该字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。 如果数组的组件类型是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上。 如果数组的组件类型不是引用类型，Java虚拟机将会把数组C标记为与引导类加载器关联。 数组类的可访问性与它的组件类型的可访问性一致。 3.2. 验证 验证：是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。 《Java虚拟机规范》的早期版本（第1、2版）对这个阶段的检验指导是相当模糊和笼统的，规范中仅列举了一些对Class文件格式的静态和结构化的约束，要求虚拟机验证到输入的字节流如不符合Class文件格式的约束，就应当抛出一个java.lang.VerifyError异常或其子类异常，但具体应当检查哪些内容、如何检查、何时进行检查等，都没有足够具体的要求和明确的说明。 直到2011年《Java虚拟机规范（Java SE 7版）》出版，规范中大幅增加了验证过程的描述（篇幅从不到10页增加到130页），这时验证阶段的约束和验证规则才变得具体起来。 3.2.1. 文件格式验证 文件格式验证：要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理： 是否以魔数0xCAFEBABE开头。 主、次版本号是否在当前Java虚拟机接受范围之内。 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。 Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。 …… 这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。 3.2.2. 元数据验证 元数据验证：是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求： 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。 这个类的父类是否继承了不允许被继承的类（被final修饰的类）。 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。 …… 第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息。 3.2.3. 字节码验证 字节码验证：是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。也就是说这个阶段要对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为： 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作。 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。 保证方法体中的类型转换总是有效的。 由于数据流分析和控制流分析的高度复杂性，Java虚拟机的设计团队为了避免过多的执行时间消耗在字节码验证阶段中，在JDK 6之后的Javac编译器和Java虚拟机里进行了一项联合优化，把尽可能多的校验辅助措施挪到Javac编译器里进行。 具体做法是给方法体Code属性的属性表中新增加了一项名为“StackMapTable”的新属性。实现字节码验证的类型推导转变为类型检查，从而节省了大量校验时间。 JDK 7之后，尽管虚拟机中仍然保留着类型推导验证器的代码，但是对于主版本号大于50（对应JDK6）的Class文件，使用类型检查来完成数据流分析校验则是唯一的选择，不允许再退回到原来的类型推导的校验方式。 3.2.4. 符号引用验证 符号引用验证：可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。 符号引用中通过字符串描述的全限定名是否能找到对应的类。 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。 符号引用中的类、字段、方法的可访问性（private、protected、public、\\）是否可被当前类访问。 …… 符号引用验证的主要目的是确保解析行为能正常执行，如果无法通过符号引用验证，Java虚拟机将会抛出一个java.lang.IncompatibleClassChangeError的子类异常，典型的如：java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。 验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但却不是必须要执行的阶段，如果程序运行的全部代码都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用-Xverify：none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 3.3. 准备 准备阶段：是正式为类中定义的变量（即静态变量）分配内存并设置类变量初始值（”通常情况“下是零值）的阶段。 public static int value = 123; 上面的变量value在准备阶段过后的初始值为0而不是123，因为这时尚未开始执行任何Java方法。 而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器\\()方法之中，所以把value赋值为123的动作要到类的初始化阶段才会被执行。 public static final int value = 123; 编译时Javac将会为value生成ConstantValue属性。 在准备阶段虚拟机就会根据Con-stantValue的设置将value赋值为123。 3.4. 解析 解析阶段：是Java虚拟机将常量池内的符号引用替换为直接引用的过程。 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。 符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。 直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。 直接引用是和虚拟机实现的内存布局直接相关的，如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。 除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存，从而避免解析动作重复进行。 无论是否真正执行了多次解析动作，Java虚拟机都需要保证的是在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直能够成功；同样地，如果第一次解析失败了，其他指令对这个符号的解析请求也应该收到相同的异常。 但是当碰到某个前面已经由invokedynamic指令触发过解析的符号引用时，并不意味着这个解析结果对于其他invokedynamic指令也同样生效。 因为invokedynamic指令的目的本来就是用于动态语言支持，它对应的引用称为“动态调用点限定符（Dynamically-Computed Call Site Specifier）”，这里“动态”的含义是指必须等到程序实际运行到这条指令时，解析动作才能进行。 解析动作主要针对 类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 这7类符号引用进行，分别对应于常量池的 CONSTANT_Class_info、CON-STANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dyna-mic_info和CONSTANT_InvokeDynamic_info 8种常量类型 3.4.1. 类或接口的解析 假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤： 如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。 如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第一点的规则加载数组元素类型。 如果上面两步没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。 在JDK 9引入了模块化以后，一个public类型也不再意味着程序任何位置都有它的访问权限，我们还必须检查模块间的访问权限。 假设D拥有C的访问权限，那就意味着以下3条规则中至少有一条成立： 被访问类C是public的，并且与访问类D处于同一个模块。 被访问类C是public的，不与访问类D处于同一个模块，但是被访问类C的模块允许被访问类D的模块进行访问。 被访问类C不是public的，但是它与访问类D处于同一个包中。 3.4.2. 字段解析 假设被解析的字段所属的类或接口用C表示，《Java虚拟机规范》要求按照如下步骤对C进行后续字段的搜索： 如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。 否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。 否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。 否则，查找失败，抛出java.lang.NoSuchFieldError异常。 如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。 3.4.3. 方法解析 假设被解析的方法所属的类或接口用C表示，《Java虚拟机规范》要求按照如下步骤对C进行后续方法的搜索： 由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的方法表中发现class_index中索引的C是个接口的话，那就直接抛出java.lang.IncompatibleClassChangeError异常。 如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。 否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。 否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出java.lang.AbstractMethodError异常。 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。 最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。 3.4.4. 接口方法解析 假设被解析的接口方法所属的接口用C表示，《Java虚拟机规范》要求按照如下步骤对C进行后续接口方法的搜索： 与类的方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那么就直接抛出java.lang.IncompatibleClassChangeError异常。 否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。 否则，在接口C的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。 对于规则3，由于Java的接口允许多重继承，如果C的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找。 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。 在JDK 9中增加了接口的静态私有方法，也有了模块化的访问约束，所以从JDK 9起，接口方法的访问也完全有可能因访问权限控制而出现java.lang.IllegalAccessError异常。 3.5. 初始化 直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。 初始化阶段：就是执行类构造器\\()方法的过程。\\()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。 \\()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的。 \\()方法不需要显式地调用父类构造器，Java虚拟机会保证在子类的\\()方法执行前，父类的\\()方法已经执行完毕。 如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的\\()方法，其他线程都需要阻塞等待，直到活动线程执行完毕\\()方法。此时其余线程就会跳过\\()，因为同一个类加载器下，一个类型只会被初始化一次。 4. 类加载器 Java虚拟机设计团队有意把类加载阶段中的 “通过一个类的全限定名来获取描述该类的二进制字节流” 这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为 “类加载器”。 4.1. 类与类加载器 对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性。而每个类加载器都拥有一个独立的类名称空间。 4.2. 双亲委派机制 从Java虚拟机角度来看只有两种类加载器： 启动类加载器（BootstrapClassLoader）：使用C++语言实现，是虚拟机自身的一部分。 其它类加载器：使用Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。 启动类加载器（Bootstrap Class Loader）：前面已经介绍过，这个类加载器负责加载存放在 \\\\lib 目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的类库加载到虚拟机的内存中。 扩展类加载器（Extension Class Loader）：这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载 \\\\lib\\ext 目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。 应用程序类加载器（Application Class Loader）：这个类加载器由sun.misc.Launcher$AppClassLoader来实现。它负责加载 ClassPath 上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用 组合（Composition）关系 来复用父加载器的代码。 5. Java模块化系统 在JDK 9中引入的 Java模块化系统（Java Platform Module System，JPMS） 是对Java技术的一次重要升级，为了能够实现模块化的关键目标—— 可配置的封装隔离机制 ，Java虚拟机对类加载架构也做出了相应的变动调整，才使模块化系统得以顺利地运作。 Java的模块定义包括： 代码的容器 依赖其他模块的列表 导出的包列表 开放的包列表 使用的服务列表 提高服务的实现列表 模块可以声明对其他模块的显式依赖，这样Java虚拟机就能够在启动时，验证应用程序开发阶段设定好的依赖关系在运行期是否完备，如有缺失那就直接启动失败，从而避免了很大一部分由于类型依赖而引发的运行时异常。 模块提供了更精细的可访问性控制，必须明确声明其中哪一些public的类型可以被其他哪一些模块访问，这种访问控制也主要是在类加载过程中完成的。 5.1. 模块的兼容性 为了使可配置的封装隔离机制能够兼容传统的类路径查找机制，JDK 9提出了与 “类路径”（ClassPath） 相对应的 “模块路径”（ModulePath） 的概念：某个类库到底是模块还是JAR包，只取决于它存放在哪种路径上。 JAR文件在类路径的访问规则：所有类路径下的JAR文件及其他资源文件，都被视为自动打包在一个匿名模块里，这个匿名模块几乎是没有任何隔离的，它可以看到和使用类路径上所有的包、JDK系统模块中所有的导出包，以及模块路径上所有模块中导出的包。 模块在模块路径的访问规则：模块路径下的具名模块只能访问到它依赖定义中列明依赖的模块和包，匿名模块里所有的内容对具名模块来说都是不可见的，即具名模块看不见传统JAR包的内容。 JAR文件在模块路径的访问规则：如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个自动模块。尽管不包含module-info.class，但自动模块将默认依赖于整个模块路径中的所有模块，因此可以访问到所有模块导出的包，自动模块也默认导出自己所有的包。 5.2. 模块化下的类加载器 为了保证兼容性，JDK 9并没有从根本上动摇从JDK 1.2以来运行了二十年之久的三层类加载器架构以及双亲委派模型。但是仍存在一些微小的变动： 扩展类加载器（Extension Class Loader）被平台类加载器（Platform Class Loader）取代。因为Java类库已经天然地满足了可扩展的需求。也因此新版JDK取消了\\\\jre目录，因为随时可以组合构建出程序运行所需的JRE来。 平台类加载器和应用程序类加载器都不再派生自java.net.URLClassLoader，现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader。 在JDK 9中，当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。 By YangXin Xu            updated 2023-10-10 16:57:03 "},"第8章-虚拟机字节码执行引擎.html":{"url":"第8章-虚拟机字节码执行引擎.html","title":"第8章-虚拟机字节码执行引擎","keywords":"","body":"1. 概述2. 运行时栈帧结构2.1. 局部变量表2.2. 操作数栈2.3. 动态链接2.3.1. 方法返回地址3. 方法调用3.1. 解析3.2. 分派3.2.1. 静态分派3.2.2. 动态分派3.2.3. 单分派与多分派3.2.4. 虚拟机动态分派的实现4. 动态类型语言支持4.1. 动态类型语言4.1.1. java.lang.invoke包4.2. invokedynamic指令4.3. 实战：掌控方法分派规则5. 基于栈的字节码解释执行引擎5.1. 基于栈的指令集与基于寄存器的指令集5.2. 基于栈的解释器执行过程1. 概述 物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的。 虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。 在《Java虚拟机规范》中制定了Java虚拟机字节码执行引擎的概念模型，这个概念模型成为各大发行商的Java虚拟机执行引擎的统一外观。 2. 运行时栈帧结构 Java虚拟机以方法作为最基本的执行单元。 每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译时，栈帧中需要多大的局部变量表、多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。 典型的栈帧结构如下图所示： 2.1. 局部变量表 局部变量表（Local Variables Table）：是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。 局部变量表的容量以变量槽（Variable Slot）为最小单位。 一般而言：一个变量槽都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据 Java虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量。 当一个方法被调用时，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程。如果执行的是实例方法，那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用。 为了尽可能节省栈帧耗用的内存空间，局部变量表中的变量槽是可以重用的。 2.2. 操作数栈 操作数栈也常被称为操作栈。同局部变量表一样，其最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。操作数栈的每个元素都可以是包括long和double在内的任意Java数据类型。 Java虚拟机的解释执行引擎被称为“基于栈的执行引擎”，里面的“栈”就是操作数栈。 在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，是完全相互独立的。但是在大多虚拟机的实现里都会进行一些优化处理，令两个栈帧出现一部分重叠。 2.3. 动态链接 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。 2.3.1. 方法返回地址 正常返回：行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者。 异常返回：在方法执行的过程中遇到了异常，并且在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。 方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有： 复上层方法的局部变量表和操作数栈。 把返回值（如果有的话）压入调用者栈帧的操作数栈中。 调整PC计数器的值以指向方法调用指令后面的一条指令。 …… 3. 方法调用 方法调用阶段唯一的任务就是确定被调用方法的版本，暂时还未涉及方法内部的具体运行过程。 一切方法调用在Class文件里面存储的都只是符号引用而非直接引用，某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。 3.1. 解析 所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用。 在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用（换句话说，调用目标在编译后就已经确定下来）。这类方法的调用被称为解析。 在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要有静态方法和私有方法两大类 静态方法：与类型直接关联 私有方法：外部不可访问 这导致他们无法通过继承等方式被重写，因此适合在类加载阶段进行解析。 Java虚拟机支持以下5条方法调用字节码指令 invokestatic：用于调用静态方法。 invokespecial：用于调用实例构造器\\()方法、私有方法和父类中的方法。 invokevirtual：用于调用所有的虚方法。 invokeinterface：用于调用接口方法，会在运行时再确定一个实现该接口的对象。 invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面4条调用指令，分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。 非虚方法：能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，包括静态方法、私有方法、实例构造器、父类方法4种，再加上被final修饰的方法，这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。他们被统称为“非虚方法”。 虚方法：其它指令调用的方法即为虚方法。 3.2. 分派 3.2.1. 静态分派 package org.fenixsoft.polymorphic; /** * 方法静态分派演示 * @author zzm */ public class StaticDispatch { static abstract class Human { } static class Man extends Human { } static class Woman extends Human { } public void sayHello(Human guy) { System.out.println(\"hello,guy!\"); } public void sayHello(Man guy) { System.out.println(\"hello,gentleman!\"); } public void sayHello(Woman guy) { System.out.println(\"hello,lady!\"); } public static void main(String[] args) { Human man = new Man(); Human woman = new Woman(); StaticDispatch sr = new StaticDispatch(); sr.sayHello(man); sr.sayHello(woman); } } result: hello,guy! hello,guy! 静态类型：其变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且终的静态类型是在编译期可知的； 实际类型：其变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。 由于虚拟机（准确讲是编译器）在重载时通过参数的静态类型而不是实际类型作为判定依据的，因此上述代码选择了第一个函数原型，将此方法的符号引用写到了main()方法里的两条invokevirtual指令的参数中。 所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。 析与分派这两者之间的关系并不是二选一的排他关系，它们是在不同层次上去筛选、确定目标方法的过程。例如前面说过静态方法会在编译期确定、在类加载期就进行解析，而静态方法显然也是可以拥有重载版本的，选择重载版本的过程也是通过静态分派完成的。 3.2.2. 动态分派 package org.fenixsoft.polymorphic; /** * 方法动态分派演示 * @author zzm */ public class DynamicDispatch { static abstract class Human { protected abstract void sayHello(); } static class Man extends Human { @Override protected void sayHello() { System.out.println(\"man say hello\"); } } static class Woman extends Human { @Override protected void sayHello() { System.out.println(\"woman say hello\"); } } public static void main(String[] args) { Human man = new Man(); Human woman = new Woman(); man.sayHello(); woman.sayHello(); man = new Woman(); man.sayHello(); } } result: man say hello woman say hello woman say hello 静态类型同样都是Human的两个变量man和woman在调用sayHello()方法时产生了不同的行为，显然此时选择调用的方法版本肯定是根据变量的实际类型来决定的。 查看字节码可知，调用方法所对应的指令是 invokevirtual 。 根据《Java虚拟机规范》，invokevirtual指令的运行时解析过程大致分为以下几步： 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。 如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IllegalAccessError异常。 否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。 我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。 注意，这种多态性的根源在于虚方法调用指令invokevirtual的执行逻辑，但是字段并没有对应的虚指令。所以只有虚方法而没有虚字段。 3.2.3. 单分派与多分派 方法的接收者与方法的参数统称为方法的宗量。 单分派是根据一个宗量对目标方法进行选择。 多分派则是根据多于一个宗量对目标方法进行选择。 Java语言的静态分派属于多分派类型。 Java语言的动态分派属于单分派类型。 3.2.4. 虚拟机动态分派的实现 出于执行性能的考虑，Java虚拟机真正运行时一般会对分派调用进行优化。常见手段是在方法区中建立一个虚方法表，使用虚方法表索引来代替元数据查找以提高性能： 虚方法表中存放着各个方法的实际入口地址。 如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。 如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。 为了程序实现方便，具有相同签名的方法，在父类、子类的虚方法表中都应当具有一样的索引序号。 虚方法表一般在类加载的连接阶段进行初始化。 4. 动态类型语言支持 Java虚拟机的字节码指令集的数量自从Sun公司的第一款Java虚拟机问世至今，二十余年间只新增过一条指令，它就是随着JDK 7的发布的字节码首位新成员——invokedynamic指令。 这条新增加的指令是JDK 7的项目目标：实现动态类型语言支持而进行的改进之一，也是为JDK 8里可以顺利实现Lambda表达式而做的技术储备。 4.1. 动态类型语言 动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的。 静态类型语言能够在编译期确定变量类型，最显著的好处是编译器可以提供全面严谨的类型检查，这样与数据类型相关的潜在问题就能在编码时被及时发现，利于稳定性及让项目容易达到更大的规模。 动态类型语言在运行期才确定类型，这可以为开发人员提供极大的灵活性，某些在静态类型语言中要花大量臃肿代码来实现的功能，由动态类型语言去做可能会很清晰简洁，清晰简洁通常也就意味着开发效率的提升。 4.1.1. java.lang.invoke包 JDK 7时新加入的java.lang.invoke包是JSR 292的一个重要组成部分，这个包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这条路之外，提供一种新的动态确定目标方法的机制，称为“方法句柄”（Method Handle）。 方法句柄演示： import static java.lang.invoke.MethodHandles.lookup; import java.lang.invoke.MethodHandle; import java.lang.invoke.MethodType; /** * JSR 292 MethodHandle基础用法演示 * @author zzm */ public class MethodHandleTest { static class ClassA { public void println(String s) { System.out.println(s); } } public static void main(String[] args) throws Throwable { Object obj = System.currentTimeMillis() % 2 == 0 ? System.out : new ClassA(); // 无论obj最终是哪个实现类，下面这句都能正确调用到println方法。 getPrintlnMH(obj).invokeExact(\"icyfenix\"); } private static MethodHandle getPrintlnMH(Object reveiver) throws Throwable { // MethodType：代表“方法类型”，包含了方法的返回值（methodType()的第一个参数）和具体参数（methodType()第二个及以后的参数）。 MethodType mt = MethodType.methodType(void.class, String.class); // lookup()方法来自于MethodHandles.lookup，这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄。 // 因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者，也即this指向的对象，这个参数以前是放在参数列表中进行传递，现在提供了bindTo()方法来完成这件事情。 return lookup().findVirtual(reveiver.getClass(), \"println\", mt) .bindTo(reveiver); } } Reflection和MethodHandle机制本质上都是在模拟方法调用，但是Reflection是在模拟Java代码层次的方法调用，而MethodHandle是在模拟字节码层次的方法调用。 Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的java.lang.invoke.MethodHandle对象所包含的信息来得多。前者是方法在Java端的全面映像，包含了方法的签名、描述符以及方法属性表中各种属性的Java端表示方式，还包含执行权限等的运行期信息。而后者仅包含执行该方法的相关信息。 由于MethodHandle是对字节码的方法指令调用的模拟，那理论上虚拟机在这方面做的各种优化（如方法内联），在MethodHandle上也应当可以采用类似思路去支持（但目前实现还在继续完善中），而通过反射去调用方法则几乎不可能直接去实施各类调用点优化措施。 Reflection API的设计目标是只为Java语言服务的，而MethodHandle则设计为可服务于所有Java虚拟机之上的语言。 4.2. invokedynamic指令 某种意义上，invokedynamic指令与MethodHandle机制的作用是一样的，是为了解决有4条“invoke*”指令方法分派规则完全固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中。 每一处含有invokedynamic指令的位置都被称作“动态调用点（Dynamically-Computed Call Site）。 该指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是变为JDK 7时新加入的 CONSTANT_InvokeDynamic_info常量 ，从这个新常量中可以得到3项信息： 引导方法（Bootstrap Method）：它有固定的参数，并且返回值规定是java.lang.invoke.CallSite对象，这个对象代表了真正要执行的目标方法调用。 方法类型（MethodType） 名称（Name） 4.3. 实战：掌控方法分派规则 （略） 5. 基于栈的字节码解释执行引擎 在本节中，我们将会分析在概念模型（而非实际模型）下的Java虚拟机解释执行字节码时，其执行引擎是如何工作的。 C/C++语言：词法、语法分析以至后面的优化器和目标代码生成器都选择独立于执行引擎，形成一个完整意义的编译器去实现。 Java语言：把其中一部分步骤（如生成抽象语法树之前的步骤）实现为一个半独立的编译器。 JavaScript执行引擎：把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子之中。 在Java语言中，Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。 一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现。 5.1. 基于栈的指令集与基于寄存器的指令集 Javac编译器输出的字节码指令流，基本上是一种基于栈的指令集架构。 基于栈的指令集主要优点： 可移植：因为寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。 代码相对更加紧凑：字节码中每个字节就对应一条指令，而多地址指令集中还需要存放参数 编译器实现更加简单：不需要考虑空间分配的问题，所需空间都在栈上操作 栈架构指令集的主要缺点： 理论上执行速度相对来说会稍慢一些。 在解释执行时，栈架构指令集的代码虽然紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构来得更多。 5.2. 基于栈的解释器执行过程 public int calc() { int a = 100; int b = 200; int c = 300; return (a + b) * c; } 其字节码的解释执行过程： By YangXin Xu            updated 2023-10-11 14:32:09 "},"第9章-类加载及执行子系统的案例与实战.html":{"url":"第9章-类加载及执行子系统的案例与实战.html","title":"第9章-类加载及执行子系统的案例与实战","keywords":"","body":" By YangXin Xu            updated 2023-10-11 14:33:48 "},"第10章-前端编译与优化.html":{"url":"第10章-前端编译与优化.html","title":"第10章-前端编译与优化","keywords":"","body":"1. 概述2. Javac编译器2.1. Javac的源码与调试2.2. 解析与填充符号表2.2.1. 词法、语法分析2.2.2. 填充符号表2.3. 注解处理器2.4. 语义分析与字节码生成2.4.1. 标注检查2.4.2. 数据及控制流分析2.4.3. 解语法糖2.4.4. 字节码生成3. Java语法糖的味道3.1. 泛型3.1.1. Java与C#的泛型3.1.2. 类型擦除3.1.3. 值类型与未来的泛型3.2. 自动装箱、拆箱与遍历循环3.3. 条件编译4. 实战：插入式注解处理器1. 概述 我们可以依据Java的不同编译过程来将编译器产品分为如下三类： 前端编译器：JDK的Javac、Eclipse JDT中的增量式编译器（ECJ）。 即时编译器：HotSpot虚拟机的C1、C2编译器，Graal编译器。 提前编译器：JDK的Jaotc、GNU Compiler for the Java（GCJ）、Excelsior JET。 前端编译器对代码的运行效率几乎没有任何优化措施可言（在JDK 1.3之后，Javac的-O优化参数就不再有意义），这是因为Java虚拟机设计团队选择把对性能的优化全部集中到运行期的即时编译器中，这样可以让那些不是由Javac产生的Class文件也同样能享受到编译器优化措施所带来的性能红利。 如果把“优化”的定义放宽，把对开发阶段的优化也计算进来的话，Javac确实是做了许多针对Java语言编码过程的优化措施来降低程序员的编码复杂度、提高编码效率。 相当多新生的Java语法特性，都是靠编译器的“语法糖”来实现，而不是依赖字节码或者Java虚拟机的底层改进来支持。 2. Javac编译器 2.1. Javac的源码与调试 《Java虚拟机规范》中严格定义了Class文件格式的各种细节，可是对如何把Java源码编译为Class文件却描述得相当宽松。 但这种宽松也导致了Class文件编译过程在某种程度上是与具体的JDK或编译器实现相关的，譬如在一些极端情况下，可能会出现某些代码在Javac编译器可以编译，但是ECJ编译器就不可以编译的问题。 从Javac代码的总体结构来看，编译过程大致可以分为1个准备过程和3个处理过程： 准备过程：初始化插入式注解处理器。 解析与填充符号表过程： 词法、语法分析：将源代码的字符流转变为标记集合，构造出抽象语法树。 填充符号表：产生符号地址和符号信息。 插入式注解处理器的注解处理过程 分析与字节码生成过程，包括： 标注检查：对语法的静态信息进行检查。 数据流及控制流分析：对程序动态运行过程进行检查。 解语法糖：将简化代码编写的语法糖还原为原有的形式。 字节码生成：将前面各个步骤所生成的信息转化成字节码。 2.2. 解析与填充符号表 解析过程由上图的parseFiles()方法来完成，解析过程包括了经典程序编译原理中的词法分析和语法分析两个步骤。 2.2.1. 词法、语法分析 词法分析是将源代码的字符流转变为标记（Token，编译时的最小元素）集合的过程。 在Javac的源码中，词法分析过程由com.sun.tools.javac.parser.Scanner类来实现。 语法分析是根据标记序列构造 抽象语法树（一种用来描述程序代码语法结构的树形表示方式） 的过程，抽象语法树的每一个节点都代表着程序代码中的一个 语法结构（例如包、类型、修饰符、运算符、接口、返回值、代码注释等）。 经过词法和语法分析生成语法树以后，后续的操作都建立在抽象语法树之上。 2.2.2. 填充符号表 下一个阶段是对符号表进行填充的过程，也就是图10-5中enterTrees()方法要做的事情。 符号表：由一组符号地址和符号信息构成的数据结构。 在Javac源代码中，填充符号表的过程由com.sun.tools.javac.comp.Enter类实现。该过程的产出物是一个待处理列表，其中包含了每个编译单元的抽象语法树的顶级节点。 2.3. 注解处理器 JDK 6设计了一组被称为 “插入式注解处理器” 的标准API，可以提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程。 以把插入式注解处理器看作是一组编译器的插件，当这些插件工作时，允许读取、修改、添加抽象语法树中的任意元素。 在Javac源码中，插入式注解处理器的初始化过程是在initPorcessAnnotations()方法中完成的，而它的执行过程则是在processAnnotations()方法中完成。 这个方法会判断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.JavacProcessing-Environment类的doProcessing()方法来生成一个新的JavaCompiler对象，对编译的后续步骤进行处理。 2.4. 语义分析与字节码生成 抽象语法树能够表示一个结构正确的源程序，但无法保证源程序的语义是符合逻辑的。 语义分析的主要任务：对结构上正确的源程序进行上下文相关性质的检查，譬如进行类型检查、控制流检查、数据流检查等。 Javac在编译过程中，语义分析过程可分为 标注检查 和 数据及控制流分析 两个步骤，分别由图10-5的attribute()和flow()方法完成。 2.4.1. 标注检查 标注检查步骤要检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。 标注检查中，还会顺便进行一个称为常量折叠的代码优化，这是Javac编译器会对源代码做的极少量优化措施之一（代码优化几乎都在即时编译器中进行）。 标注检查步骤在Javac源码中的实现类是com.sun.tools.javac.comp.Attr类和com.sun.tools.javac.comp.Check类。 2.4.2. 数据及控制流分析 数据流分析和控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。 在Javac的源码中，数据及控制流分析的具体操作由com.sun.tools.javac.comp.Flow类来完成。 2.4.3. 解语法糖 语法糖（Syntactic Sugar）：也称糖衣语法，指的是在计算机语言中添加的某种语法，这种语法对语言的编译结果和功能并没有实际影响，但是却能更方便程序员使用该语言。 常来说使用语法糖能够减少代码量、增加程序的可读性，从而减少程序代码出错的机会。 Java中最常见的语法糖包括了前面提到过的泛型、变长参数、自动装箱拆箱等。 Java虚拟机运行时并不直接支持这些语法，它们在编译阶段被还原回原始的基础语法结构，这个过程就称为解语法糖。 在Javac的源码中，解语法糖的过程由desugar()方法触发，在com.sun.tools.javac.comp.TransTypes类和com.sun.tools.javac.comp.Lower类中完成。 2.4.4. 字节码生成 字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成。 字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码指令写到磁盘中，编译器还进行了少量的代码添加和转换工作。 例如前文多次登场的实例构造器\\()方法和类构造器\\()方法就是在这个阶段被添加到语法树之中的。 \\()和\\()这两个构造器的产生实际上是一种代码收敛的过程，编译器会把语句块、变量初始化、调用父类的实例构造器等操作收敛到\\()和\\()方法之中。 完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交到com.sun.tools.javac.jvm.ClassWriter类手上，由这个类的writeClass()方法输出字节码，生成最终的Class文件，到此，整个编译过程宣告结束。 3. Java语法糖的味道 3.1. 泛型 泛型的本质是 参数化类型 或者 参数化多态 的应用：即可以将操作的数据类型指定为方法签名中的一种特殊参数，这种参数类型能够用在类、接口和方法的创建中，分别构成泛型类、泛型接口和泛型方法。 3.1.1. Java与C#的泛型 Java选择的泛型实现方式叫作 “类型擦除式泛型”（Type Erasure Generics），而C#选择的泛型实现方式是 “具现化式泛型”（Reified Generics）。 C#中的泛型无论在程序源码、编译后的中间语言表示、运行期的CLR里面都是切实存在的。List\\与List\\就是两个不同的类型，它们由系统在运行期生成，有着自己独立的虚方法表和类型数据。 Java语言中的泛型只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型，并且在相应的地方插入了强制转型代码。因此在运行期，ArrayList\\与ArrayList\\是同一个类型。 3.1.2. 类型擦除 由于Java选择直接把已有的类型泛型化。由此就引出了 裸类型 的概念，裸类型应被视为所有该类型泛型化实例的共同父类型。这使得如下Java代码被认为是系统允许的从子类到父类的安全转型： ArrayList ilist = new ArrayList(); ArrayList slist = new ArrayList(); ArrayList list; // 裸类型 list = ilist; list = slist; 关于如何实现 “裸类型” 有如下两种路径： 运行期由Java虚拟机来自动地、真实地构造出ArrayList\\这样的类型，并且自动实现从ArrayList\\派生自ArrayList的继承关系。 单粗暴地直接在编译时把ArrayList\\还原回ArrayList，只在元素访问、修改时自动插入一些强制类型转换和检查指令。 显然Java选择了后者。 泛型带来的问题： 使用擦除法实现泛型直接导致了对原始类型数据(int,long,char…)的支持又成了新的麻烦。Java使用自动装箱/拆箱进行补丁，但这又导致泛型代码运行慢。 运行期无法取得泛型类型信息，而这会让一些代码变得相当啰嗦。 通过擦除法来实现泛型，还丧失了一些面向对象思想应有的优雅，带来了一些模棱两可的模糊状况。 3.1.3. 值类型与未来的泛型 C#并没有Java意义上的原生数据类型，在C#中使用的int、bool、double关键字其实是对应了一系列在.NET框架中预定义好的结构体，如Int32、Boolean、Double等。在C#中可以定义自己的值类型，只要继承于ValueType类型即可，而ValueType也是统一基类Object的子类，所以并不会遇到Java那样int不自动装箱就无法转型为Object的尴尬。 值类型可以与引用类型一样，具有构造函数、方法或是属性字段等等。它与引用类型的区别在于它在赋值的时候通常是整体复制，而不是像引用类型那样传递引用的。 类型的实例很容易实现分配在方法的调用栈上的，这意味着值类型会随着当前方法的退出而自动释放，不会给垃圾收集子系统带来任何压力。 3.2. 自动装箱、拆箱与遍历循环 public static void main(String[] args) { List list = Arrays.asList(1, 2, 3, 4); int sum = 0; for (int i : list) { sum += i; } System.out.println(sum); } 展开后的等价代码： public static void main(String[] args) { List list = Arrays.asList( new Integer[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3), Integer.valueOf(4) }); int sum = 0; for (Iterator localIterator = list.iterator(); localIterator.hasNext(); ) { int i = ((Integer)localIterator.next()).intValue(); sum += i; } System.out.println(sum); } 上述代码一共包含了泛型、自动装箱、自动拆箱、遍历循环与变长参数5种语法糖。 自动装箱、拆箱在编译之后被转化成了对应的包装和还原方法。 遍历循环则是把代码还原成了迭代器的实现，这也是遍历循环需要被遍历的类实现Iterable接口的原因。 变长参数在调用的时候变成了一个数组类型的参数 3.3. 条件编译 Java语义可以进行条件编译，就是 使用条件为常量的if语句。下面的代码中的if语句不同于其它Java代码，它在编译阶段就会被前端编译器探查到，生成的字节码中只包括block 1的代码；而不包含block 2的代码。 public static void main(String[] args) { if (true) { System.out.println(\"block 1\"); } else { System.out.println(\"block 2\"); } } 只能使用条件为常量的if语句才能达到上述效果，如果使用常量与其他带有条件判断能力的语句搭配，则可能在控制流分析中提示错误，被拒绝编译。比如下面的代码就会被拒绝编译： public static void main(String[] args) { // 编译器将会提示“Unreachable code” while (false) { System.out.println(\"\"); } } Java语言中条件编译的实现，是一种语法糖，根据布尔常量值的真假，编译器将会把分支中不成立的代码块消除掉，这一工作将在编译器解除语法糖阶段完成。 由于if语句只能写在方法体内部，因此Java语言的条件编译只能实现Block级别的条件编译，而没有办法实现根据条件调整整个Java类的结构。 4. 实战：插入式注解处理器 （略） By YangXin Xu            updated 2023-10-11 19:17:08 "},"第11章-后端编译与优化.html":{"url":"第11章-后端编译与优化.html","title":"第11章-后端编译与优化","keywords":"","body":"1. 概述2. 即时编译器2.1. 解释器与编译器2.2. 编译对象与触发条件1. 概述 如果我们把字节码看作是程序语言的一种中间表示形式（Intermediate Representation，IR）的话，那编译器无论在何时、在何种状态下把Class文件转换成与本地相关的二进制机器码，它都可以视为整个编译过程的后端。 2. 即时编译器 虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为“热点代码”（Hot Spot Code），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行时完成这个任务的后端编译器被称为即时编译器。 2.1. 解释器与编译器 目前主流的商用Java虚拟机，譬如HotSpot、OpenJ9等，内部都同时包含解释器与编译器： 当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。 程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率。 当程序运行环境中内存资源限制较大，可以使用解释执行节约内存。 解释器还可以作为编译器激进优化时后备的“逃生门”。 编译器根据概率选择一些不能保证所有情况都正确，但大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类以后，类型继承结构出现变化、出现 “罕见陷阱” 时可以通过 逆优化 退回到解释状态继续执行。 总之，整个Java虚拟机执行架构里，解释器与编译器经常是相辅相成地配合工作。 HotSpot虚拟机中内置了两/三个即时编译器： 客户端编译器：又称C1编译器 服务端编译器：又称C2编译器 Graal编译器：在JDK10中出现，长期目标是代替C2的Graal编译器。但Graal编译器目前还处于实验状态。 在分层编译的工作模式出现以前，HotSpot虚拟机通常是采用解释器与其中一个编译器直接搭配的方式工作，程序使用哪个编译器只取决于虚拟机运行的模式，HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用“-client”或“-server”参数去强制指定虚拟机运行在客户端模式还是服务端模式。 无论采用的编译器是客户端编译器还是服务端编译器，解释器与编译器搭配使用的方式在虚拟机中被称为 “混合模式” 。 用户也可以使用参数“-Xint”强制虚拟机运行于 “解释模式” ：这时候编译器完全不介入工作，全部代码都使用解释方式执行。 也可以使用参数“-Xcomp”强制虚拟机运行于 “编译模式” ：这时候将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。 由于即时编译器编译本地代码需要占用程序运行时间，通常要编译出优化程度越高的代码，所花费的时间便会越长；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行阶段的速度也有所影响。 为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机在编译子系统中加入了 分层编译 的功能： 第0层：程序纯解释执行，并且解释器不开启性能监控功能。 第1层：使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能。 第2层：仍然使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能。 第3层：仍然使用客户端编译器执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。 第4层：使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。 2.2. 编译对象与触发条件 热点代码主要有如下两类： 被多次调用的方法。 被多次调用的循环体。 By YangXin Xu            updated 2023-10-11 19:58:59 "}}